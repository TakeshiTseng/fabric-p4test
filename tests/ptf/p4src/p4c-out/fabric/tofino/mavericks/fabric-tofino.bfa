version:
  version: 1.0.1
  run_id: "978dc5e43e3e6f2f"
phv ingress:
  compiler_generated_meta.bridged_metadata.bridged_metadata_indicator: TB0
  fabric_metadata.ip_eth_type: TH3
  fabric_metadata.mpls_ttl: B3
  fabric_metadata.eth_type: H7
  fabric_metadata.vlan_pri: B8(5..7)
  fabric_metadata.vlan_cfi: B8(4)
  compiler_generated_meta.bridged_metadata.__pad_0: B8(3)
  fabric_metadata.clone_to_cpu: B8(2)
  fabric_metadata.is_multicast: B8(1)
  fabric_metadata.is_controller_packet_out: B8(0)
  compiler_generated_meta.bridged_metadata.__pad_1: B5(1..7)
  ig_intr_md.ingress_port.0-7: B4
  ig_intr_md.ingress_port.8-8: B5(0)
  compiler_generated_meta.bridged_metadata.__pad_2: B6(4..7)
  fabric_metadata.vlan_id.0-7: B10
  fabric_metadata.vlan_id.8-11: B6(0..3)
  fabric_metadata.mpls_label.0-3: B2(4..7)
  fabric_metadata.mpls_label.4-19: H8
  compiler_generated_meta.bridged_metadata.__pad_3: B2(0..3)
  hdr.packet_out.egress_port: H0(7..15)
  hdr.ethernet.dst_addr.0-15: H9
  hdr.ethernet.dst_addr.16-47: W0
  hdr.ethernet.src_addr.0-15: H5
  hdr.ethernet.src_addr.16-47: W1
  hdr.ethernet.eth_type: TH1
  hdr.vlan_tag.pri: B7(5..7)
  hdr.vlan_tag.cfi: B7(4)
  hdr.vlan_tag.vlan_id.0-7: B9
  hdr.vlan_tag.vlan_id.8-11: B7(0..3)
  hdr.vlan_tag.eth_type: H6
  hdr.ipv4.version: TW0(28..31)
  hdr.ipv4.ihl: TW0(24..27)
  hdr.ipv4.dscp: TW0(18..23)
  hdr.ipv4.ecn: TW0(16..17)
  hdr.ipv4.total_len: TW0(0..15)
  hdr.ipv4.identification: TW8(16..31)
  hdr.ipv4.flags: TW8(13..15)
  hdr.ipv4.frag_offset: TW8(0..12)
  hdr.ipv4.ttl: TW9(24..31)
  hdr.ipv4.protocol: TW9(16..23)
  hdr.ipv4.hdr_checksum: TW9(0..15)
  hdr.ipv4.src_addr: W2
  hdr.ipv4.dst_addr: W3
  fabric_metadata.skip_forwarding: H3(10)
  fabric_metadata.skip_next: B12(0)
  fabric_metadata.fwd_type: B13(3..5)
  fabric_metadata.next_id: W4
  fabric_metadata.ip_proto: B11
  fabric_metadata.l4_sport: H10
  fabric_metadata.l4_dport: H11
  hdr.tcp.sport: TH2
  hdr.tcp.dport: TH0
  hdr.tcp.seq_no: TW11
  hdr.tcp.ack_no: TW16
  hdr.tcp.data_offset: TW1(28..31)
  hdr.tcp.res: TW1(25..27)
  hdr.tcp.ecn: TW1(22..24)
  hdr.tcp.ctrl: TW1(16..21)
  hdr.tcp.window: TW1(0..15)
  hdr.tcp.checksum: TW10(16..31)
  hdr.tcp.urgent_ptr: TW10(0..15)
  hdr.udp.sport: TW1(16..31)
  hdr.udp.dport: TW1(0..15)
  hdr.udp.len: TW10(16..31)
  hdr.udp.checksum: TW10(0..15)
  hdr.icmp.icmp_type: H4(8..15)
  hdr.icmp.icmp_code: H4(0..7)
  hdr.icmp.checksum: TH0
  hdr.icmp.identifier: TW1(16..31)
  hdr.icmp.sequence_number: TW1(0..15)
  hdr.icmp.timestamp.0-31: TW10
  hdr.icmp.timestamp.32-63: TW11
  hdr.mpls.label: TW2(12..31)
  hdr.mpls.tc: TW2(9..11)
  hdr.mpls.bos: TW2(8)
  hdr.mpls.ttl: TW2(0..7)
  hdr.inner_vlan_tag.pri: TW3(29..31)
  hdr.inner_vlan_tag.cfi: TW3(28)
  hdr.inner_vlan_tag.vlan_id: TW3(16..27)
  hdr.inner_vlan_tag.eth_type: TW3(0..15)
  hasExited: B13(6)
  ig_intr_md_for_tm.ucast_egress_port: H1(0..8)
  ig_intr_md_for_tm.mcast_grp_a: H2
  ig_intr_md_for_dprsr.drop_ctl: B0(0..2)
  ig_intr_md_for_dprsr.mirror_type: B1(0..2)
  compiler_generated_meta.mirror_id: H3(0..9)
  compiler_generated_meta.bridged_metadata.$valid: B12(1)
  hdr.ethernet.$valid: B12(2)
  hdr.icmp.$valid: B12(3)
  hdr.inner_vlan_tag.$valid: B12(4)
  hdr.ipv4.$valid: B12(5)
  hdr.mpls.$valid: B12(6)
  hdr.packet_out.$valid: B12(7)
  hdr.tcp.$valid: B13(0)
  hdr.udp.$valid: B13(1)
  hdr.vlan_tag.$valid: B13(2)
  context_json:
    TB0:
      compiler_generated_meta.bridged_metadata.bridged_metadata_indicator:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TH0:
      hdr.icmp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.dport ]
      hdr.tcp.dport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum ]
    TH1:
      hdr.ethernet.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TH2:
      hdr.tcp.sport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TH3:
      fabric_metadata.ip_eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW0:
      hdr.ipv4.total_len:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.ecn:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.dscp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.ihl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.version:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW1:
      hdr.tcp.window:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.dport, hdr.udp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.tcp.ctrl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.dport, hdr.udp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.tcp.ecn:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.dport, hdr.udp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.tcp.res:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.dport, hdr.udp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.tcp.data_offset:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.dport, hdr.udp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.udp.dport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.udp.sport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.icmp.sequence_number:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.udp.dport, hdr.udp.sport ]
      hdr.icmp.identifier:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.udp.dport, hdr.udp.sport ]
    TW2:
      hdr.mpls.ttl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.bos:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.tc:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.label:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW3:
      hdr.inner_vlan_tag.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.cfi:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.pri:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW8:
      hdr.ipv4.frag_offset:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.flags:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.identification:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW9:
      hdr.ipv4.hdr_checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.protocol:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.ttl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW10:
      hdr.tcp.urgent_ptr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.checksum, hdr.udp.len, hdr.icmp.timestamp ]
      hdr.tcp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.checksum, hdr.udp.len, hdr.icmp.timestamp ]
      hdr.udp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.urgent_ptr, hdr.tcp.checksum, hdr.icmp.timestamp ]
      hdr.udp.len:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.urgent_ptr, hdr.tcp.checksum, hdr.icmp.timestamp ]
      hdr.icmp.timestamp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.urgent_ptr, hdr.tcp.checksum, hdr.udp.checksum, hdr.udp.len ]
    TW11:
      hdr.tcp.seq_no:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.timestamp ]
      hdr.icmp.timestamp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.seq_no ]
    TW16:
      hdr.tcp.ack_no:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B0:
      ig_intr_md_for_dprsr.drop_ctl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B1:
      ig_intr_md_for_dprsr.mirror_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B2:
      compiler_generated_meta.bridged_metadata.__pad_3:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.mpls_label:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B3:
      fabric_metadata.mpls_ttl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B4:
      ig_intr_md.ingress_port:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B5:
      ig_intr_md.ingress_port:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      compiler_generated_meta.bridged_metadata.__pad_1:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B6:
      fabric_metadata.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      compiler_generated_meta.bridged_metadata.__pad_2:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B7:
      hdr.vlan_tag.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.cfi:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.pri:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B8:
      fabric_metadata.is_controller_packet_out:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.is_multicast:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.clone_to_cpu:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      compiler_generated_meta.bridged_metadata.__pad_0:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.vlan_cfi:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.vlan_pri:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B9:
      hdr.vlan_tag.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B10:
      fabric_metadata.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B11:
      fabric_metadata.ip_proto:
          live_start: parser
          live_end: 7
          mutually_exclusive_with: [  ]
    B12:
      fabric_metadata.skip_next:
          live_start: parser
          live_end: 6
          mutually_exclusive_with: [  ]
      compiler_generated_meta.bridged_metadata.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ethernet.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.icmp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.packet_out.$valid:
          live_start: parser
          live_end: 1
          mutually_exclusive_with: [  ]
    B13:
      hdr.tcp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.udp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.fwd_type:
          live_start: 3
          live_end: 4
          mutually_exclusive_with: [  ]
      hasExited:
          live_start: 0
          live_end: 2
          mutually_exclusive_with: [  ]
    H0:
      hdr.packet_out.egress_port:
          live_start: parser
          live_end: 1
          mutually_exclusive_with: [  ]
    H1:
      ig_intr_md_for_tm.ucast_egress_port:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H2:
      ig_intr_md_for_tm.mcast_grp_a:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H3:
      compiler_generated_meta.mirror_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      fabric_metadata.skip_forwarding:
          live_start: parser
          live_end: 4
          mutually_exclusive_with: [  ]
    H4:
      hdr.icmp.icmp_code:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.icmp.icmp_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H5:
      hdr.ethernet.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H6:
      hdr.vlan_tag.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H7:
      fabric_metadata.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H8:
      fabric_metadata.mpls_label:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H9:
      hdr.ethernet.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H10:
      fabric_metadata.l4_sport:
          live_start: parser
          live_end: 7
          mutually_exclusive_with: [  ]
    H11:
      fabric_metadata.l4_dport:
          live_start: parser
          live_end: 7
          mutually_exclusive_with: [  ]
    W0:
      hdr.ethernet.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    W1:
      hdr.ethernet.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    W2:
      hdr.ipv4.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    W3:
      hdr.ipv4.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    W4:
      fabric_metadata.next_id:
          live_start: parser
          live_end: 7
          mutually_exclusive_with: [  ]
phv egress:
  eg_intr_md.egress_port: H17(0..8)
  ig_intr_md.ingress_port: H16(0..8)
  fabric_metadata.eth_type: H25
  fabric_metadata.ip_eth_type: H24
  fabric_metadata.vlan_id: H20(0..11)
  fabric_metadata.vlan_pri: H19(5..7)
  fabric_metadata.vlan_cfi: H19(4)
  fabric_metadata.mpls_label.0-3: B20(4..7)
  fabric_metadata.mpls_label.4-19: H26
  fabric_metadata.mpls_ttl: B16
  fabric_metadata.is_multicast: H19(1)
  fabric_metadata.is_controller_packet_out: H19(0)
  fabric_metadata.clone_to_cpu: H19(2)
  hdr.ethernet.dst_addr.0-15: TH7
  hdr.ethernet.dst_addr.16-47: TW15
  hdr.ethernet.src_addr.0-15: TH6
  hdr.ethernet.src_addr.16-47: TW14
  hdr.ethernet.eth_type: H23
  hdr.vlan_tag.pri: H21(13..15)
  hdr.vlan_tag.cfi: H21(12)
  hdr.vlan_tag.vlan_id: H21(0..11)
  hdr.vlan_tag.eth_type: H22
  hdr.ipv4.version: TW4(28..31)
  hdr.ipv4.ihl: TW4(24..27)
  hdr.ipv4.dscp: TW4(18..23)
  hdr.ipv4.ecn: TW4(16..17)
  hdr.ipv4.total_len: TW4(0..15)
  hdr.ipv4.identification: TW7(16..31)
  hdr.ipv4.flags: TW7(13..15)
  hdr.ipv4.frag_offset: TW7(0..12)
  hdr.ipv4.ttl: B18
  hdr.ipv4.protocol: TB5
  hdr.ipv4.hdr_checksum.0-7: TB6
  hdr.ipv4.hdr_checksum.8-15: TB4
  hdr.ipv4.src_addr: TW20
  hdr.ipv4.dst_addr: TW21
  hdr.tcp.sport: TW12(16..31)
  hdr.tcp.dport: TW12(0..15)
  hdr.tcp.seq_no: TW22
  hdr.tcp.ack_no: TW23
  hdr.tcp.data_offset: TW5(28..31)
  hdr.tcp.res: TW5(25..27)
  hdr.tcp.ecn: TW5(22..24)
  hdr.tcp.ctrl: TW5(16..21)
  hdr.tcp.window: TW5(0..15)
  hdr.tcp.checksum: TW13(16..31)
  hdr.tcp.urgent_ptr: TW13(0..15)
  hdr.udp.sport: TW5(16..31)
  hdr.udp.dport: TW5(0..15)
  hdr.udp.len: TW12(16..31)
  hdr.udp.checksum: TW12(0..15)
  hdr.icmp.icmp_type: TW5(24..31)
  hdr.icmp.icmp_code: TW5(16..23)
  hdr.icmp.checksum: TW5(0..15)
  hdr.icmp.identifier: TW12(16..31)
  hdr.icmp.sequence_number: TW12(0..15)
  hdr.icmp.timestamp.0-31: TW13
  hdr.icmp.timestamp.32-63: TW22
  hdr.mpls.label.0-3: B21(4..7)
  hdr.mpls.label.4-19: H27
  hdr.mpls.tc: B21(1..3)
  hdr.mpls.bos: B21(0)
  hdr.mpls.ttl: B17
  hdr.inner_vlan_tag.pri: TW6(29..31)
  hdr.inner_vlan_tag.cfi: TW6(28)
  hdr.inner_vlan_tag.vlan_id: TW6(16..27)
  hdr.inner_vlan_tag.eth_type: TW6(0..15)
  hasExited_0: B20(0)
  eg_intr_md_for_dprsr.drop_ctl: B19(0..2)
  hdr.packet_in.ingress_port: H18(7..15)
  hdr.packet_in._pad: H18(0..6)
  hdr.ethernet.$valid: B22(0)
  hdr.icmp.$valid: B22(1)
  hdr.inner_vlan_tag.$valid: B22(2)
  hdr.ipv4.$valid: B22(3)
  hdr.mpls.$valid: B22(4)
  hdr.packet_in.$valid: B23(0)
  hdr.tcp.$valid: B22(5)
  hdr.udp.$valid: B22(6)
  hdr.vlan_tag.$valid: B22(7)
  context_json:
    TB4:
      hdr.ipv4.hdr_checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TB5:
      hdr.ipv4.protocol:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TB6:
      hdr.ipv4.hdr_checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TH6:
      hdr.ethernet.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TH7:
      hdr.ethernet.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW4:
      hdr.ipv4.total_len:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.ecn:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.dscp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.ihl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.version:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW5:
      hdr.tcp.window:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type, hdr.udp.dport, hdr.udp.sport ]
      hdr.tcp.ctrl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type, hdr.udp.dport, hdr.udp.sport ]
      hdr.tcp.ecn:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type, hdr.udp.dport, hdr.udp.sport ]
      hdr.tcp.res:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type, hdr.udp.dport, hdr.udp.sport ]
      hdr.tcp.data_offset:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type, hdr.udp.dport, hdr.udp.sport ]
      hdr.icmp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.udp.dport, hdr.udp.sport ]
      hdr.icmp.icmp_code:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.udp.dport, hdr.udp.sport ]
      hdr.icmp.icmp_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.udp.dport, hdr.udp.sport ]
      hdr.udp.dport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type ]
      hdr.udp.sport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.window, hdr.tcp.ctrl, hdr.tcp.ecn, hdr.tcp.res, hdr.tcp.data_offset, hdr.icmp.checksum, hdr.icmp.icmp_code, hdr.icmp.icmp_type ]
    TW6:
      hdr.inner_vlan_tag.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.cfi:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.pri:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW7:
      hdr.ipv4.frag_offset:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.flags:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.identification:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW12:
      hdr.tcp.dport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.checksum, hdr.udp.len, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.tcp.sport:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.udp.checksum, hdr.udp.len, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.udp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.dport, hdr.tcp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.udp.len:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.dport, hdr.tcp.sport, hdr.icmp.sequence_number, hdr.icmp.identifier ]
      hdr.icmp.sequence_number:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.dport, hdr.tcp.sport, hdr.udp.checksum, hdr.udp.len ]
      hdr.icmp.identifier:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.dport, hdr.tcp.sport, hdr.udp.checksum, hdr.udp.len ]
    TW13:
      hdr.tcp.urgent_ptr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.timestamp ]
      hdr.tcp.checksum:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.timestamp ]
      hdr.icmp.timestamp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.urgent_ptr, hdr.tcp.checksum ]
    TW14:
      hdr.ethernet.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW15:
      hdr.ethernet.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW20:
      hdr.ipv4.src_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW21:
      hdr.ipv4.dst_addr:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    TW22:
      hdr.tcp.seq_no:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.icmp.timestamp ]
      hdr.icmp.timestamp:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [ hdr.tcp.seq_no ]
    TW23:
      hdr.tcp.ack_no:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B16:
      fabric_metadata.mpls_ttl:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
    B17:
      hdr.mpls.ttl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B18:
      hdr.ipv4.ttl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B19:
      eg_intr_md_for_dprsr.drop_ctl:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B20:
      fabric_metadata.mpls_label:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
      hasExited_0:
          live_start: 0
          live_end: 3
          mutually_exclusive_with: [  ]
    B21:
      hdr.mpls.bos:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.tc:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.label:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B22:
      hdr.ethernet.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.icmp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.inner_vlan_tag.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.ipv4.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.mpls.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.tcp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.udp.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.$valid:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    B23:
      hdr.packet_in.$valid:
          live_start: 2
          live_end: deparser
          mutually_exclusive_with: [  ]
    H16:
      ig_intr_md.ingress_port:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
    H17:
      eg_intr_md.egress_port:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H18:
      hdr.packet_in._pad:
          mutually_exclusive_with: [  ]
      hdr.packet_in.ingress_port:
          live_start: 2
          live_end: deparser
          mutually_exclusive_with: [  ]
    H19:
      fabric_metadata.vlan_pri:
          live_start: parser
          live_end: 5
          mutually_exclusive_with: [  ]
      fabric_metadata.vlan_cfi:
          live_start: parser
          live_end: 5
          mutually_exclusive_with: [  ]
      fabric_metadata.is_multicast:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
      fabric_metadata.is_controller_packet_out:
          live_start: parser
          live_end: 1
          mutually_exclusive_with: [  ]
      fabric_metadata.clone_to_cpu:
          live_start: parser
          live_end: 2
          mutually_exclusive_with: [  ]
    H20:
      fabric_metadata.vlan_id:
          live_start: parser
          live_end: 5
          mutually_exclusive_with: [  ]
    H21:
      hdr.vlan_tag.vlan_id:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.cfi:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
      hdr.vlan_tag.pri:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H22:
      hdr.vlan_tag.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H23:
      hdr.ethernet.eth_type:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
    H24:
      fabric_metadata.ip_eth_type:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
    H25:
      fabric_metadata.eth_type:
          live_start: parser
          live_end: 5
          mutually_exclusive_with: [  ]
    H26:
      fabric_metadata.mpls_label:
          live_start: parser
          live_end: 3
          mutually_exclusive_with: [  ]
    H27:
      hdr.mpls.label:
          live_start: parser
          live_end: deparser
          mutually_exclusive_with: [  ]
parser ingress:
  start: $entry_point.$ingress_tna_entry_point.$ingress_metadata
  init_zero: [ TH3, B3, H7, B8, B5, B6, B10, B2, H8, H3, B12, B13, W4, B11, H10, H11, B0 ]
  multi_write: [ TH0, TH1, TH3, TW1, TW2, TW3, TW10, TW11, B2, B3, B5, B6, B7, B9, B10, B11, B12, B13, H5, H6, H7, H8, H9, H10, H11, W0, W1, W3 ]
  hdr_len_adj: 16
  states:
    $entry_point.$ingress_tna_entry_point.$ingress_metadata:  # from state $entry_point.$ingress_tna_entry_point.$ingress_metadata
      0:
        0: B5  # N[7]b -> B5 L[0]b: ingress::compiler_generated_meta.^bridged_metadata.ig_intr_md_ingress_port.8-8
        1: B4  # ingress::compiler_generated_meta.^bridged_metadata.ig_intr_md_ingress_port.0-7
        TB0: 0  # value 0 -> TB0 L[0..7]b: ingress::compiler_generated_meta.^bridged_metadata.^bridged_metadata_indicator
        B12: 2  # value 1 -> B12 L[1]b: ingress::compiler_generated_meta.^bridged_metadata.$valid
        save: { byte0 : 0, byte1 : 1 }
        shift: 8
        buf_req: 8
        next: $check_resubmit
    $check_resubmit:  # from state ingress::$check_resubmit
      match: [ byte0 ]
      # - match N[-8]B: cast
      0b0*******:
        buf_req: 0
        next: $phase0
      0b1*******:
        buf_req: 0
        next: $resubmit
    $phase0:  # from state ingress::$phase0
      0:
        shift: 8
        buf_req: 8
        next: $skip_to_packet.start
    $skip_to_packet.start:  # from state $skip_to_packet.start
      match: [ byte0, byte1 ]
      # - match N[-16..-15]B: ig_intr_md.ingress_port
      0b*******101000000:
        buf_req: 0
        next: parse_packet_out
      0x****:
        save: { byte0 : 12, byte1 : 13 }
        buf_req: 14
        next: parse_ethernet
    parse_packet_out:  # from state ingress::parse_packet_out
      0:
        0..1: H0  # N[0..8]b -> H0 L[7..15]b: ingress::hdr.packet_out.egress_port
        B12: 128  # value 1 -> B12 L[7]b: ingress::hdr.packet_out.$valid
        save: { byte0 : 14, byte1 : 15 }
        shift: 2
        buf_req: 16
        next: parse_ethernet
    parse_ethernet:  # from state ingress::parse_ethernet
      match: [ byte0, byte1 ]
      # - match N[12..13]B: hdr.ethernet.eth_type
      0x8100:
        0..3: W0  # ingress::hdr.ethernet.dst_addr.16-47
        4..5: H9  # ingress::hdr.ethernet.dst_addr.0-15
        6..9: W1  # ingress::hdr.ethernet.src_addr.16-47
        10..11: H5  # ingress::hdr.ethernet.src_addr.0-15
        12..13: TH1  # ingress::hdr.ethernet.eth_type
        12..13: H7  # ingress::compiler_generated_meta.^bridged_metadata.md_eth_type
        B6: 15  # value 4094 -> B6 L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.8-11
        B10: 254  # value 4094 -> B10 L[0..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.0-7
        B12: 4  # value 1 -> B12 L[2]b: ingress::hdr.ethernet.$valid
        save: { byte0 : 16, byte1 : 17 }
        shift: 14
        buf_req: 18
        next: parse_vlan_tag
      0x8847:
        0..3: W0  # ingress::hdr.ethernet.dst_addr.16-47
        4..5: H9  # ingress::hdr.ethernet.dst_addr.0-15
        6..9: W1  # ingress::hdr.ethernet.src_addr.16-47
        10..11: H5  # ingress::hdr.ethernet.src_addr.0-15
        12..13: TH1  # ingress::hdr.ethernet.eth_type
        12..13: H7  # ingress::compiler_generated_meta.^bridged_metadata.md_eth_type
        B6: 15  # value 4094 -> B6 L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.8-11
        B10: 254  # value 4094 -> B10 L[0..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.0-7
        B12: 4  # value 1 -> B12 L[2]b: ingress::hdr.ethernet.$valid
        save: { byte0 : 18 }
        shift: 14
        buf_req: 19
        next: parse_mpls
      0x0800:
        0..3: W0  # ingress::hdr.ethernet.dst_addr.16-47
        4..5: H9  # ingress::hdr.ethernet.dst_addr.0-15
        6..9: W1  # ingress::hdr.ethernet.src_addr.16-47
        10..11: H5  # ingress::hdr.ethernet.src_addr.0-15
        12..13: TH1  # ingress::hdr.ethernet.eth_type
        12..13: H7  # ingress::compiler_generated_meta.^bridged_metadata.md_eth_type
        B6: 15  # value 4094 -> B6 L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.8-11
        B10: 254  # value 4094 -> B10 L[0..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.0-7
        B12: 4  # value 1 -> B12 L[2]b: ingress::hdr.ethernet.$valid
        save: { byte0 : 23 }
        shift: 14
        buf_req: 24
        next: parse_ipv4.$common
      0x****:
        0..3: W0  # ingress::hdr.ethernet.dst_addr.16-47
        4..5: H9  # ingress::hdr.ethernet.dst_addr.0-15
        6..9: W1  # ingress::hdr.ethernet.src_addr.16-47
        10..11: H5  # ingress::hdr.ethernet.src_addr.0-15
        12..13: TH1  # ingress::hdr.ethernet.eth_type
        12..13: H7  # ingress::compiler_generated_meta.^bridged_metadata.md_eth_type
        B6: 15  # value 4094 -> B6 L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.8-11
        B10: 254  # value 4094 -> B10 L[0..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.0-7
        B12: 4  # value 1 -> B12 L[2]b: ingress::hdr.ethernet.$valid
        shift: 14
        buf_req: 14
        next: end
    parse_vlan_tag:  # from state ingress::parse_vlan_tag
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.vlan_tag.eth_type
      0x0800:
        0: B7
            # - N[0..2]b -> B7 L[5..7]b: ingress::hdr.vlan_tag.pri
            # - N[3]b -> B7 L[4]b: ingress::hdr.vlan_tag.cfi
            # - N[4..7]b -> B7 L[0..3]b: ingress::hdr.vlan_tag.vlan_id.8-11
        1: B9  # ingress::hdr.vlan_tag.vlan_id.0-7
        2..3: H6  # ingress::hdr.vlan_tag.eth_type
        B13: 4  # value 1 -> B13 L[2]b: ingress::hdr.vlan_tag.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common
      0x8847:
        0: B7
            # - N[0..2]b -> B7 L[5..7]b: ingress::hdr.vlan_tag.pri
            # - N[3]b -> B7 L[4]b: ingress::hdr.vlan_tag.cfi
            # - N[4..7]b -> B7 L[0..3]b: ingress::hdr.vlan_tag.vlan_id.8-11
        1: B9  # ingress::hdr.vlan_tag.vlan_id.0-7
        2..3: H6  # ingress::hdr.vlan_tag.eth_type
        B13: 4  # value 1 -> B13 L[2]b: ingress::hdr.vlan_tag.$valid
        save: { byte0 : 8 }
        shift: 4
        buf_req: 9
        next: parse_mpls
      0x8100:
        0: B7
            # - N[0..2]b -> B7 L[5..7]b: ingress::hdr.vlan_tag.pri
            # - N[3]b -> B7 L[4]b: ingress::hdr.vlan_tag.cfi
            # - N[4..7]b -> B7 L[0..3]b: ingress::hdr.vlan_tag.vlan_id.8-11
        1: B9  # ingress::hdr.vlan_tag.vlan_id.0-7
        2..3: H6  # ingress::hdr.vlan_tag.eth_type
        B13: 4  # value 1 -> B13 L[2]b: ingress::hdr.vlan_tag.$valid
        save: { byte0 : 6, byte1 : 7 }
        shift: 4
        buf_req: 8
        next: parse_inner_vlan_tag
      0x****:
        0: B7
            # - N[0..2]b -> B7 L[5..7]b: ingress::hdr.vlan_tag.pri
            # - N[3]b -> B7 L[4]b: ingress::hdr.vlan_tag.cfi
            # - N[4..7]b -> B7 L[0..3]b: ingress::hdr.vlan_tag.vlan_id.8-11
        1: B9  # ingress::hdr.vlan_tag.vlan_id.0-7
        2..3: H6  # ingress::hdr.vlan_tag.eth_type
        B13: 4  # value 1 -> B13 L[2]b: ingress::hdr.vlan_tag.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_ipv4.$common:
      0:
        0..3: TW0
            # - N[0..3]b -> TW0 L[28..31]b: ingress::hdr.ipv4.version
            # - N[4..7]b -> TW0 L[24..27]b: ingress::hdr.ipv4.ihl
            # - N[8..13]b -> TW0 L[18..23]b: ingress::hdr.ipv4.dscp
            # - N[14..15]b -> TW0 L[16..17]b: ingress::hdr.ipv4.ecn
            # - N[16..31]b -> TW0 L[0..15]b: ingress::hdr.ipv4.total_len
        4..7: TW8
            # - N[32..47]b -> TW8 L[16..31]b: ingress::hdr.ipv4.identification
            # - N[48..50]b -> TW8 L[13..15]b: ingress::hdr.ipv4.flags
            # - N[51..63]b -> TW8 L[0..12]b: ingress::hdr.ipv4.frag_offset
        9: B11  # ingress::fabric_metadata.ip_proto
        8..11: TW9
            # - N[64..71]b -> TW9 L[24..31]b: ingress::hdr.ipv4.ttl
            # - N[72..79]b -> TW9 L[16..23]b: ingress::hdr.ipv4.protocol
            # - N[80..95]b -> TW9 L[0..15]b: ingress::hdr.ipv4.hdr_checksum
        12..15: W2  # ingress::hdr.ipv4.src_addr
        TH3: 2048  # value 2048 -> TH3 L[0..15]b: ingress::compiler_generated_meta.^bridged_metadata.md_ip_eth_type
        B12: 32  # value 1 -> B12 L[5]b: ingress::hdr.ipv4.$valid
        shift: 16
        buf_req: 16
        next: parse_ipv4
    parse_ipv4:  # from state ingress::parse_ipv4
      match: [ byte0 ]
      # - match N[9]B: hdr.ipv4.protocol
      0x06:
        0..3: W3  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: parse_tcp
      0x11:
        0..3: W3  # ingress::hdr.ipv4.dst_addr
        save: { byte0 : 6, byte1 : 7 }
        shift: 4
        buf_req: 8
        next: parse_udp
      0x01:
        0..3: W3  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: parse_icmp
      0x**:
        0..3: W3  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: end
    parse_tcp:  # from state ingress::parse_tcp
      0:
        0..1: TH2  # ingress::hdr.tcp.sport
        0..1: H10  # ingress::fabric_metadata.l4_sport
        2..3: TH0  # ingress::hdr.tcp.dport
        2..3: H11  # ingress::fabric_metadata.l4_dport
        4..7: TW11  # ingress::hdr.tcp.seq_no
        8..11: TW16  # ingress::hdr.tcp.ack_no
        12..15: TW1
            # - N[96..99]b -> TW1 L[28..31]b: ingress::hdr.tcp.data_offset
            # - N[100..102]b -> TW1 L[25..27]b: ingress::hdr.tcp.res
            # - N[103..105]b -> TW1 L[22..24]b: ingress::hdr.tcp.ecn
            # - N[106..111]b -> TW1 L[16..21]b: ingress::hdr.tcp.ctrl
            # - N[112..127]b -> TW1 L[0..15]b: ingress::hdr.tcp.window
        16..19: TW10
            # - N[128..143]b -> TW10 L[16..31]b: ingress::hdr.tcp.checksum
            # - N[144..159]b -> TW10 L[0..15]b: ingress::hdr.tcp.urgent_ptr
        B13: 1  # value 1 -> B13 L[0]b: ingress::hdr.tcp.$valid
        shift: 20
        buf_req: 20
        next: end
    parse_udp:  # from state ingress::parse_udp
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.udp.dport
      0x****:
        0..1: H10  # ingress::fabric_metadata.l4_sport
        0..3: TW1
            # - N[0..15]b -> TW1 L[16..31]b: ingress::hdr.udp.sport
            # - N[16..31]b -> TW1 L[0..15]b: ingress::hdr.udp.dport
        2..3: H11  # ingress::fabric_metadata.l4_dport
        4..7: TW10
            # - N[32..47]b -> TW10 L[16..31]b: ingress::hdr.udp.len
            # - N[48..63]b -> TW10 L[0..15]b: ingress::hdr.udp.checksum
        B13: 2  # value 1 -> B13 L[1]b: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_icmp:  # from state ingress::parse_icmp
      0:
        0..1: H4
            # - N[0..7]b -> H4 L[8..15]b: ingress::hdr.icmp.icmp_type
            # - N[8..15]b -> H4 L[0..7]b: ingress::hdr.icmp.icmp_code
        2..3: TH0  # ingress::hdr.icmp.checksum
        4..7: TW1
            # - N[32..47]b -> TW1 L[16..31]b: ingress::hdr.icmp.identifier
            # - N[48..63]b -> TW1 L[0..15]b: ingress::hdr.icmp.sequence_number
        8..11: TW11  # ingress::hdr.icmp.timestamp.32-63
        12..15: TW10  # ingress::hdr.icmp.timestamp.0-31
        B12: 8  # value 1 -> B12 L[3]b: ingress::hdr.icmp.$valid
        shift: 16
        buf_req: 16
        next: end
    parse_mpls:  # from state ingress::parse_mpls
      match: [ byte0 ]
      # - match N[4]B: packet.lookahead
      0x4*:
        0..1: H8  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.4-19
        2: B2  # N[16..19]b -> B2 L[4..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.0-3
        0..3: TW2
            # - N[0..19]b -> TW2 L[12..31]b: ingress::hdr.mpls.label
            # - N[20..22]b -> TW2 L[9..11]b: ingress::hdr.mpls.tc
            # - N[23]b -> TW2 L[8]b: ingress::hdr.mpls.bos
            # - N[24..31]b -> TW2 L[0..7]b: ingress::hdr.mpls.ttl
        3: B3  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_ttl
        B12: 64  # value 1 -> B12 L[6]b: ingress::hdr.mpls.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common
      0x**:
        0..1: H8  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.4-19
        2: B2  # N[16..19]b -> B2 L[4..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.0-3
        0..3: TW2
            # - N[0..19]b -> TW2 L[12..31]b: ingress::hdr.mpls.label
            # - N[20..22]b -> TW2 L[9..11]b: ingress::hdr.mpls.tc
            # - N[23]b -> TW2 L[8]b: ingress::hdr.mpls.bos
            # - N[24..31]b -> TW2 L[0..7]b: ingress::hdr.mpls.ttl
        3: B3  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_ttl
        B12: 64  # value 1 -> B12 L[6]b: ingress::hdr.mpls.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_inner_vlan_tag:  # from state ingress::parse_inner_vlan_tag
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.inner_vlan_tag.eth_type
      0x0800:
        0..3: TW3
            # - N[0..2]b -> TW3 L[29..31]b: ingress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW3 L[28]b: ingress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW3 L[16..27]b: ingress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW3 L[0..15]b: ingress::hdr.inner_vlan_tag.eth_type
        B12: 16  # value 1 -> B12 L[4]b: ingress::hdr.inner_vlan_tag.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common
      0x8847:
        0..3: TW3
            # - N[0..2]b -> TW3 L[29..31]b: ingress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW3 L[28]b: ingress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW3 L[16..27]b: ingress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW3 L[0..15]b: ingress::hdr.inner_vlan_tag.eth_type
        B12: 16  # value 1 -> B12 L[4]b: ingress::hdr.inner_vlan_tag.$valid
        save: { byte0 : 8 }
        shift: 4
        buf_req: 9
        next: parse_mpls
      0x****:
        0..3: TW3
            # - N[0..2]b -> TW3 L[29..31]b: ingress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW3 L[28]b: ingress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW3 L[16..27]b: ingress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW3 L[0..15]b: ingress::hdr.inner_vlan_tag.eth_type
        B12: 16  # value 1 -> B12 L[4]b: ingress::hdr.inner_vlan_tag.$valid
        shift: 4
        buf_req: 4
        next: end
    $resubmit:  # from state $resubmit
      0:
        shift: 8
        buf_req: 8
        next: $skip_to_packet.start
deparser ingress:
  dictionary:
    TB0: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.^bridged_metadata_indicator if ingress::compiler_generated_meta.^bridged_metadata.$valid
    TH3: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.md_ip_eth_type if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B3: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_ttl if ingress::compiler_generated_meta.^bridged_metadata.$valid
    H7: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.md_eth_type if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B8: B12(1)
        # - L[5..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_pri if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[4]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_cfi if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[3]b: ingress::compiler_generated_meta.^bridged_metadata.__pad_0 if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[2]b: ingress::compiler_generated_meta.^bridged_metadata.md_clone_to_cpu if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[1]b: ingress::compiler_generated_meta.^bridged_metadata.md_is_multicast if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[0]b: ingress::compiler_generated_meta.^bridged_metadata.md_is_controller_packet_out if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B5: B12(1)
        # - L[1..7]b: ingress::compiler_generated_meta.^bridged_metadata.__pad_1 if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[0]b: ingress::compiler_generated_meta.^bridged_metadata.ig_intr_md_ingress_port.8-8 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B4: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.ig_intr_md_ingress_port.0-7 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B6: B12(1)
        # - L[4..7]b: ingress::compiler_generated_meta.^bridged_metadata.__pad_2 if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.8-11 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B10: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.md_vlan_id.0-7 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    H8: B12(1)  # ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.4-19 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    B2: B12(1)
        # - L[4..7]b: ingress::compiler_generated_meta.^bridged_metadata.md_mpls_label.0-3 if ingress::compiler_generated_meta.^bridged_metadata.$valid
        # - L[0..3]b: ingress::compiler_generated_meta.^bridged_metadata.__pad_3 if ingress::compiler_generated_meta.^bridged_metadata.$valid
    W0: B12(2)  # ingress::hdr.ethernet.dst_addr.16-47 if ingress::hdr.ethernet.$valid
    H9: B12(2)  # ingress::hdr.ethernet.dst_addr.0-15 if ingress::hdr.ethernet.$valid
    W1: B12(2)  # ingress::hdr.ethernet.src_addr.16-47 if ingress::hdr.ethernet.$valid
    H5: B12(2)  # ingress::hdr.ethernet.src_addr.0-15 if ingress::hdr.ethernet.$valid
    TH1: B12(2)  # ingress::hdr.ethernet.eth_type if ingress::hdr.ethernet.$valid
    B7: B13(2)
        # - L[5..7]b: ingress::hdr.vlan_tag.pri if ingress::hdr.vlan_tag.$valid
        # - L[4]b: ingress::hdr.vlan_tag.cfi if ingress::hdr.vlan_tag.$valid
        # - L[0..3]b: ingress::hdr.vlan_tag.vlan_id.8-11 if ingress::hdr.vlan_tag.$valid
    B9: B13(2)  # ingress::hdr.vlan_tag.vlan_id.0-7 if ingress::hdr.vlan_tag.$valid
    H6: B13(2)  # ingress::hdr.vlan_tag.eth_type if ingress::hdr.vlan_tag.$valid
    TW3: B12(4)
        # - L[29..31]b: ingress::hdr.inner_vlan_tag.pri if ingress::hdr.inner_vlan_tag.$valid
        # - L[28]b: ingress::hdr.inner_vlan_tag.cfi if ingress::hdr.inner_vlan_tag.$valid
        # - L[16..27]b: ingress::hdr.inner_vlan_tag.vlan_id if ingress::hdr.inner_vlan_tag.$valid
        # - L[0..15]b: ingress::hdr.inner_vlan_tag.eth_type if ingress::hdr.inner_vlan_tag.$valid
    TW2: B12(6)
        # - L[12..31]b: ingress::hdr.mpls.label if ingress::hdr.mpls.$valid
        # - L[9..11]b: ingress::hdr.mpls.tc if ingress::hdr.mpls.$valid
        # - L[8]b: ingress::hdr.mpls.bos if ingress::hdr.mpls.$valid
        # - L[0..7]b: ingress::hdr.mpls.ttl if ingress::hdr.mpls.$valid
    TW0: B12(5)
        # - L[28..31]b: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - L[24..27]b: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - L[18..23]b: ingress::hdr.ipv4.dscp if ingress::hdr.ipv4.$valid
        # - L[16..17]b: ingress::hdr.ipv4.ecn if ingress::hdr.ipv4.$valid
        # - L[0..15]b: ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TW8: B12(5)
        # - L[16..31]b: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - L[13..15]b: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - L[0..12]b: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    TW9: B12(5)
        # - L[24..31]b: ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
        # - L[16..23]b: ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
        # - L[0..15]b: ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    W2: B12(5)  # ingress::hdr.ipv4.src_addr if ingress::hdr.ipv4.$valid
    W3: B12(5)  # ingress::hdr.ipv4.dst_addr if ingress::hdr.ipv4.$valid
    TH2: B13(0)  # ingress::hdr.tcp.sport if ingress::hdr.tcp.$valid
    TH0: B13(0)  # ingress::hdr.tcp.dport if ingress::hdr.tcp.$valid
    TW11: B13(0)  # ingress::hdr.tcp.seq_no if ingress::hdr.tcp.$valid
    TW16: B13(0)  # ingress::hdr.tcp.ack_no if ingress::hdr.tcp.$valid
    TW1: B13(0)
        # - L[28..31]b: ingress::hdr.tcp.data_offset if ingress::hdr.tcp.$valid
        # - L[25..27]b: ingress::hdr.tcp.res if ingress::hdr.tcp.$valid
        # - L[22..24]b: ingress::hdr.tcp.ecn if ingress::hdr.tcp.$valid
        # - L[16..21]b: ingress::hdr.tcp.ctrl if ingress::hdr.tcp.$valid
        # - L[0..15]b: ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TW10: B13(0)
        # - L[16..31]b: ingress::hdr.tcp.checksum if ingress::hdr.tcp.$valid
        # - L[0..15]b: ingress::hdr.tcp.urgent_ptr if ingress::hdr.tcp.$valid
    TW1: B13(1)
        # - L[16..31]b: ingress::hdr.udp.sport if ingress::hdr.udp.$valid
        # - L[0..15]b: ingress::hdr.udp.dport if ingress::hdr.udp.$valid
    TW10: B13(1)
        # - L[16..31]b: ingress::hdr.udp.len if ingress::hdr.udp.$valid
        # - L[0..15]b: ingress::hdr.udp.checksum if ingress::hdr.udp.$valid
    H4: B12(3)
        # - L[8..15]b: ingress::hdr.icmp.icmp_type if ingress::hdr.icmp.$valid
        # - L[0..7]b: ingress::hdr.icmp.icmp_code if ingress::hdr.icmp.$valid
    TH0: B12(3)  # ingress::hdr.icmp.checksum if ingress::hdr.icmp.$valid
    TW1: B12(3)
        # - L[16..31]b: ingress::hdr.icmp.identifier if ingress::hdr.icmp.$valid
        # - L[0..15]b: ingress::hdr.icmp.sequence_number if ingress::hdr.icmp.$valid
    TW11: B12(3)  # ingress::hdr.icmp.timestamp.32-63 if ingress::hdr.icmp.$valid
    TW10: B12(3)  # ingress::hdr.icmp.timestamp.0-31 if ingress::hdr.icmp.$valid
  egress_unicast_port: H1(0..8)  # L[0..8]b: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B0(0..2)  # L[0..2]b: ingress::ig_intr_md_for_dprsr.drop_ctl
  egress_multicast_group:
    - H2  # ingress::ig_intr_md_for_tm.mcast_grp_a
  mirror:
    select: B1(0..2)  # L[0..2]b: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H3(0..9)  # L[0..9]b: ingress::compiler_generated_meta.mirror_id
parser egress:
  start: $entry_point.$egress_tna_entry_point.$egress_metadata
  init_zero: [ H25, H24, H20, H19, B20, H26, B16, B19, B22, B23 ]
  multi_write: [ TH6, TH7, TW5, TW6, TW12, TW13, TW14, TW15, TW22, B16, B17, B20, B21, B22, H19, H20, H21, H22, H23, H24, H25, H26, H27 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.$egress_tna_entry_point.$egress_metadata:  # from state $entry_point.$egress_tna_entry_point.$egress_metadata
      0:
        0..1: H17  # N[7..15]b -> H17 L[0..8]b: egress::eg_intr_md.egress_port
        save: { byte0 : 27 }
        shift: 27
        buf_req: 28
        next: $check_mirrored
    $check_mirrored:  # from state egress::$check_mirrored
      match: [ byte0 ]
      # - match N[0]B: packet.lookahead
      0b****0***:
        buf_req: 0
        next: $bridged_metadata.$common
      0b****1***:
        save: { byte0 : 0 }
        buf_req: 1
        next: $mirrored
    $bridged_metadata.$common:
      0:
        1..2: H24  # egress::fabric_metadata.ip_eth_type
        3: B16  # egress::fabric_metadata.mpls_ttl
        4..5: H25  # egress::fabric_metadata.eth_type
        5..6: H19
            # - N[51]b -> H19 L[4]b: egress::fabric_metadata.vlan_cfi
            # - N[48..50]b -> H19 L[5..7]b: egress::fabric_metadata.vlan_pri
            # - N[55]b -> H19 L[0]b: egress::fabric_metadata.is_controller_packet_out
            # - N[54]b -> H19 L[1]b: egress::fabric_metadata.is_multicast
            # - N[53]b -> H19 L[2]b: egress::fabric_metadata.clone_to_cpu
        7..8: H16  # N[63..71]b -> H16 L[0..8]b: egress::ig_intr_md.ingress_port
        13: B20  # N[104..107]b -> B20 L[4..7]b: egress::fabric_metadata.mpls_label.0-3
        save: { byte0 : 7, byte1 : 8 }
        shift: 9
        buf_req: 14
        next: $bridged_metadata
    $bridged_metadata:  # from state egress::$bridged_metadata
      0:
        0..1: H20  # N[76..87]b -> H20 L[0..11]b: egress::fabric_metadata.vlan_id
        2..3: H26  # egress::fabric_metadata.mpls_label.4-19
        shift: 5
        buf_req: 5
        next: start
    start:  # from state egress::start
      match: [ byte0, byte1 ]
      0b*******101000000:
        buf_req: 0
        next: parse_packet_out
      0x****:
        save: { byte0 : 12, byte1 : 13 }
        buf_req: 14
        next: parse_ethernet
    parse_packet_out:  # from state egress::parse_packet_out
      0:
        save: { byte0 : 12, byte1 : 13 }
        buf_req: 14
        next: parse_ethernet
    parse_ethernet:  # from state egress::parse_ethernet
      match: [ byte0, byte1 ]
      # - match N[12..13]B: hdr.ethernet.eth_type
      0x8100:
        0..3: TW15  # egress::hdr.ethernet.dst_addr.16-47
        4..5: TH7  # egress::hdr.ethernet.dst_addr.0-15
        6..9: TW14  # egress::hdr.ethernet.src_addr.16-47
        10..11: TH6  # egress::hdr.ethernet.src_addr.0-15
        12..13: H23  # egress::hdr.ethernet.eth_type
        B22: 1  # value 1 -> B22 L[0]b: egress::hdr.ethernet.$valid
        save: { byte0 : 16, byte1 : 17 }
        shift: 14
        buf_req: 18
        next: parse_vlan_tag
      0x8847:
        0..3: TW15  # egress::hdr.ethernet.dst_addr.16-47
        4..5: TH7  # egress::hdr.ethernet.dst_addr.0-15
        6..9: TW14  # egress::hdr.ethernet.src_addr.16-47
        10..11: TH6  # egress::hdr.ethernet.src_addr.0-15
        12..13: H23  # egress::hdr.ethernet.eth_type
        B22: 1  # value 1 -> B22 L[0]b: egress::hdr.ethernet.$valid
        save: { byte0 : 18 }
        shift: 14
        buf_req: 19
        next: parse_mpls
      0x0800:
        0..3: TW15  # egress::hdr.ethernet.dst_addr.16-47
        4..5: TH7  # egress::hdr.ethernet.dst_addr.0-15
        6..9: TW14  # egress::hdr.ethernet.src_addr.16-47
        10..11: TH6  # egress::hdr.ethernet.src_addr.0-15
        12..13: H23  # egress::hdr.ethernet.eth_type
        B22: 1  # value 1 -> B22 L[0]b: egress::hdr.ethernet.$valid
        save: { byte0 : 23 }
        shift: 14
        buf_req: 24
        next: parse_ipv4.$common.0
      0x****:
        0..3: TW15  # egress::hdr.ethernet.dst_addr.16-47
        4..5: TH7  # egress::hdr.ethernet.dst_addr.0-15
        6..9: TW14  # egress::hdr.ethernet.src_addr.16-47
        10..11: TH6  # egress::hdr.ethernet.src_addr.0-15
        12..13: H23  # egress::hdr.ethernet.eth_type
        B22: 1  # value 1 -> B22 L[0]b: egress::hdr.ethernet.$valid
        shift: 14
        buf_req: 14
        next: end
    parse_vlan_tag:  # from state egress::parse_vlan_tag
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.vlan_tag.eth_type
      0x0800:
        0..1: H21
            # - N[0..2]b -> H21 L[13..15]b: egress::hdr.vlan_tag.pri
            # - N[3]b -> H21 L[12]b: egress::hdr.vlan_tag.cfi
            # - N[4..15]b -> H21 L[0..11]b: egress::hdr.vlan_tag.vlan_id
        2..3: H22  # egress::hdr.vlan_tag.eth_type
        B22: 128  # value 1 -> B22 L[7]b: egress::hdr.vlan_tag.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common.0
      0x8847:
        0..1: H21
            # - N[0..2]b -> H21 L[13..15]b: egress::hdr.vlan_tag.pri
            # - N[3]b -> H21 L[12]b: egress::hdr.vlan_tag.cfi
            # - N[4..15]b -> H21 L[0..11]b: egress::hdr.vlan_tag.vlan_id
        2..3: H22  # egress::hdr.vlan_tag.eth_type
        B22: 128  # value 1 -> B22 L[7]b: egress::hdr.vlan_tag.$valid
        save: { byte0 : 8 }
        shift: 4
        buf_req: 9
        next: parse_mpls
      0x8100:
        0..1: H21
            # - N[0..2]b -> H21 L[13..15]b: egress::hdr.vlan_tag.pri
            # - N[3]b -> H21 L[12]b: egress::hdr.vlan_tag.cfi
            # - N[4..15]b -> H21 L[0..11]b: egress::hdr.vlan_tag.vlan_id
        2..3: H22  # egress::hdr.vlan_tag.eth_type
        B22: 128  # value 1 -> B22 L[7]b: egress::hdr.vlan_tag.$valid
        save: { byte0 : 6, byte1 : 7 }
        shift: 4
        buf_req: 8
        next: parse_inner_vlan_tag
      0x****:
        0..1: H21
            # - N[0..2]b -> H21 L[13..15]b: egress::hdr.vlan_tag.pri
            # - N[3]b -> H21 L[12]b: egress::hdr.vlan_tag.cfi
            # - N[4..15]b -> H21 L[0..11]b: egress::hdr.vlan_tag.vlan_id
        2..3: H22  # egress::hdr.vlan_tag.eth_type
        B22: 128  # value 1 -> B22 L[7]b: egress::hdr.vlan_tag.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_ipv4.$common.0:
      0:
        0..3: TW4
            # - N[0..3]b -> TW4 L[28..31]b: egress::hdr.ipv4.version
            # - N[4..7]b -> TW4 L[24..27]b: egress::hdr.ipv4.ihl
            # - N[8..13]b -> TW4 L[18..23]b: egress::hdr.ipv4.dscp
            # - N[14..15]b -> TW4 L[16..17]b: egress::hdr.ipv4.ecn
            # - N[16..31]b -> TW4 L[0..15]b: egress::hdr.ipv4.total_len
        4..7: TW7
            # - N[32..47]b -> TW7 L[16..31]b: egress::hdr.ipv4.identification
            # - N[48..50]b -> TW7 L[13..15]b: egress::hdr.ipv4.flags
            # - N[51..63]b -> TW7 L[0..12]b: egress::hdr.ipv4.frag_offset
        8: B18  # egress::hdr.ipv4.ttl
        9: TB5  # egress::hdr.ipv4.protocol
        10: TB4  # egress::hdr.ipv4.hdr_checksum.8-15
        11: TB6  # egress::hdr.ipv4.hdr_checksum.0-7
        12..15: TW20  # egress::hdr.ipv4.src_addr
        16..19: TW21  # egress::hdr.ipv4.dst_addr
        shift: 20
        buf_req: 20
        next: parse_ipv4
    parse_ipv4:  # from state egress::parse_ipv4
      match: [ byte0 ]
      # - match N[9]B: hdr.ipv4.protocol
      0x06:
        B22: 8  # value 1 -> B22 L[3]b: egress::hdr.ipv4.$valid
        buf_req: 0
        next: parse_tcp.$common
      0x11:
        B22: 8  # value 1 -> B22 L[3]b: egress::hdr.ipv4.$valid
        save: { byte0 : 2, byte1 : 3 }
        buf_req: 4
        next: parse_udp
      0x01:
        B22: 8  # value 1 -> B22 L[3]b: egress::hdr.ipv4.$valid
        buf_req: 0
        next: parse_icmp
      0x**:
        B22: 8  # value 1 -> B22 L[3]b: egress::hdr.ipv4.$valid
        buf_req: 0
        next: end
    parse_tcp.$common:
      0:
        0..3: TW12
            # - N[0..15]b -> TW12 L[16..31]b: egress::hdr.tcp.sport
            # - N[16..31]b -> TW12 L[0..15]b: egress::hdr.tcp.dport
        4..7: TW22  # egress::hdr.tcp.seq_no
        8..11: TW23  # egress::hdr.tcp.ack_no
        12..15: TW5
            # - N[96..99]b -> TW5 L[28..31]b: egress::hdr.tcp.data_offset
            # - N[100..102]b -> TW5 L[25..27]b: egress::hdr.tcp.res
            # - N[103..105]b -> TW5 L[22..24]b: egress::hdr.tcp.ecn
            # - N[106..111]b -> TW5 L[16..21]b: egress::hdr.tcp.ctrl
            # - N[112..127]b -> TW5 L[0..15]b: egress::hdr.tcp.window
        B22: 32  # value 1 -> B22 L[5]b: egress::hdr.tcp.$valid
        shift: 16
        buf_req: 16
        next: parse_tcp
    parse_tcp:  # from state egress::parse_tcp
      0:
        0..3: TW13
            # - N[128..143]b -> TW13 L[16..31]b: egress::hdr.tcp.checksum
            # - N[144..159]b -> TW13 L[0..15]b: egress::hdr.tcp.urgent_ptr
        shift: 4
        buf_req: 4
        next: end
    parse_udp:  # from state egress::parse_udp
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.udp.dport
      0x****:
        0..3: TW5
            # - N[0..15]b -> TW5 L[16..31]b: egress::hdr.udp.sport
            # - N[16..31]b -> TW5 L[0..15]b: egress::hdr.udp.dport
        4..7: TW12
            # - N[32..47]b -> TW12 L[16..31]b: egress::hdr.udp.len
            # - N[48..63]b -> TW12 L[0..15]b: egress::hdr.udp.checksum
        B22: 64  # value 1 -> B22 L[6]b: egress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_icmp:  # from state egress::parse_icmp
      0:
        0..3: TW5
            # - N[0..7]b -> TW5 L[24..31]b: egress::hdr.icmp.icmp_type
            # - N[8..15]b -> TW5 L[16..23]b: egress::hdr.icmp.icmp_code
            # - N[16..31]b -> TW5 L[0..15]b: egress::hdr.icmp.checksum
        4..7: TW12
            # - N[32..47]b -> TW12 L[16..31]b: egress::hdr.icmp.identifier
            # - N[48..63]b -> TW12 L[0..15]b: egress::hdr.icmp.sequence_number
        8..11: TW22  # egress::hdr.icmp.timestamp.32-63
        12..15: TW13  # egress::hdr.icmp.timestamp.0-31
        B22: 2  # value 1 -> B22 L[1]b: egress::hdr.icmp.$valid
        shift: 16
        buf_req: 16
        next: end
    parse_mpls:  # from state egress::parse_mpls
      match: [ byte0 ]
      # - match N[4]B: packet.lookahead
      0x4*:
        0..1: H27  # egress::hdr.mpls.label.4-19
        2: B21
            # - N[16..19]b -> B21 L[4..7]b: egress::hdr.mpls.label.0-3
            # - N[20..22]b -> B21 L[1..3]b: egress::hdr.mpls.tc
            # - N[23]b -> B21 L[0]b: egress::hdr.mpls.bos
        3: B17  # egress::hdr.mpls.ttl
        B22: 16  # value 1 -> B22 L[4]b: egress::hdr.mpls.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common.0
      0x**:
        0..1: H27  # egress::hdr.mpls.label.4-19
        2: B21
            # - N[16..19]b -> B21 L[4..7]b: egress::hdr.mpls.label.0-3
            # - N[20..22]b -> B21 L[1..3]b: egress::hdr.mpls.tc
            # - N[23]b -> B21 L[0]b: egress::hdr.mpls.bos
        3: B17  # egress::hdr.mpls.ttl
        B22: 16  # value 1 -> B22 L[4]b: egress::hdr.mpls.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_inner_vlan_tag:  # from state egress::parse_inner_vlan_tag
      match: [ byte0, byte1 ]
      # - match N[2..3]B: hdr.inner_vlan_tag.eth_type
      0x0800:
        0..3: TW6
            # - N[0..2]b -> TW6 L[29..31]b: egress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW6 L[28]b: egress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW6 L[16..27]b: egress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW6 L[0..15]b: egress::hdr.inner_vlan_tag.eth_type
        B22: 4  # value 1 -> B22 L[2]b: egress::hdr.inner_vlan_tag.$valid
        save: { byte0 : 13 }
        shift: 4
        buf_req: 14
        next: parse_ipv4.$common.0
      0x8847:
        0..3: TW6
            # - N[0..2]b -> TW6 L[29..31]b: egress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW6 L[28]b: egress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW6 L[16..27]b: egress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW6 L[0..15]b: egress::hdr.inner_vlan_tag.eth_type
        B22: 4  # value 1 -> B22 L[2]b: egress::hdr.inner_vlan_tag.$valid
        save: { byte0 : 8 }
        shift: 4
        buf_req: 9
        next: parse_mpls
      0x****:
        0..3: TW6
            # - N[0..2]b -> TW6 L[29..31]b: egress::hdr.inner_vlan_tag.pri
            # - N[3]b -> TW6 L[28]b: egress::hdr.inner_vlan_tag.cfi
            # - N[4..15]b -> TW6 L[16..27]b: egress::hdr.inner_vlan_tag.vlan_id
            # - N[16..31]b -> TW6 L[0..15]b: egress::hdr.inner_vlan_tag.eth_type
        B22: 4  # value 1 -> B22 L[2]b: egress::hdr.inner_vlan_tag.$valid
        shift: 4
        buf_req: 4
        next: end
    $mirrored:  # from state egress::$mirrored
      match: [ byte0 ]
      # - match N[0]B: (buffer)
      0x**:
        shift: 1
        buf_req: 1
        next: start
deparser egress:
  dictionary:
    H18: B23(0)
        # - L[7..15]b: egress::hdr.packet_in.ingress_port if egress::hdr.packet_in.$valid
        # - L[0..6]b: egress::hdr.packet_in._pad if egress::hdr.packet_in.$valid
    TW15: B22(0)  # egress::hdr.ethernet.dst_addr.16-47 if egress::hdr.ethernet.$valid
    TH7: B22(0)  # egress::hdr.ethernet.dst_addr.0-15 if egress::hdr.ethernet.$valid
    TW14: B22(0)  # egress::hdr.ethernet.src_addr.16-47 if egress::hdr.ethernet.$valid
    TH6: B22(0)  # egress::hdr.ethernet.src_addr.0-15 if egress::hdr.ethernet.$valid
    H23: B22(0)  # egress::hdr.ethernet.eth_type if egress::hdr.ethernet.$valid
    H21: B22(7)
        # - L[13..15]b: egress::hdr.vlan_tag.pri if egress::hdr.vlan_tag.$valid
        # - L[12]b: egress::hdr.vlan_tag.cfi if egress::hdr.vlan_tag.$valid
        # - L[0..11]b: egress::hdr.vlan_tag.vlan_id if egress::hdr.vlan_tag.$valid
    H22: B22(7)  # egress::hdr.vlan_tag.eth_type if egress::hdr.vlan_tag.$valid
    TW6: B22(2)
        # - L[29..31]b: egress::hdr.inner_vlan_tag.pri if egress::hdr.inner_vlan_tag.$valid
        # - L[28]b: egress::hdr.inner_vlan_tag.cfi if egress::hdr.inner_vlan_tag.$valid
        # - L[16..27]b: egress::hdr.inner_vlan_tag.vlan_id if egress::hdr.inner_vlan_tag.$valid
        # - L[0..15]b: egress::hdr.inner_vlan_tag.eth_type if egress::hdr.inner_vlan_tag.$valid
    H27: B22(4)  # egress::hdr.mpls.label.4-19 if egress::hdr.mpls.$valid
    B21: B22(4)
        # - L[4..7]b: egress::hdr.mpls.label.0-3 if egress::hdr.mpls.$valid
        # - L[1..3]b: egress::hdr.mpls.tc if egress::hdr.mpls.$valid
        # - L[0]b: egress::hdr.mpls.bos if egress::hdr.mpls.$valid
    B17: B22(4)  # egress::hdr.mpls.ttl if egress::hdr.mpls.$valid
    TW4: B22(3)
        # - L[28..31]b: egress::hdr.ipv4.version if egress::hdr.ipv4.$valid
        # - L[24..27]b: egress::hdr.ipv4.ihl if egress::hdr.ipv4.$valid
        # - L[18..23]b: egress::hdr.ipv4.dscp if egress::hdr.ipv4.$valid
        # - L[16..17]b: egress::hdr.ipv4.ecn if egress::hdr.ipv4.$valid
        # - L[0..15]b: egress::hdr.ipv4.total_len if egress::hdr.ipv4.$valid
    TW7: B22(3)
        # - L[16..31]b: egress::hdr.ipv4.identification if egress::hdr.ipv4.$valid
        # - L[13..15]b: egress::hdr.ipv4.flags if egress::hdr.ipv4.$valid
        # - L[0..12]b: egress::hdr.ipv4.frag_offset if egress::hdr.ipv4.$valid
    B18: B22(3)  # egress::hdr.ipv4.ttl if egress::hdr.ipv4.$valid
    TB5: B22(3)  # egress::hdr.ipv4.protocol if egress::hdr.ipv4.$valid
    checksum 0: B22(3)  # egress::hdr.ipv4.$valid
    TW20: B22(3)  # egress::hdr.ipv4.src_addr if egress::hdr.ipv4.$valid
    TW21: B22(3)  # egress::hdr.ipv4.dst_addr if egress::hdr.ipv4.$valid
    TW12: B22(5)
        # - L[16..31]b: egress::hdr.tcp.sport if egress::hdr.tcp.$valid
        # - L[0..15]b: egress::hdr.tcp.dport if egress::hdr.tcp.$valid
    TW22: B22(5)  # egress::hdr.tcp.seq_no if egress::hdr.tcp.$valid
    TW23: B22(5)  # egress::hdr.tcp.ack_no if egress::hdr.tcp.$valid
    TW5: B22(5)
        # - L[28..31]b: egress::hdr.tcp.data_offset if egress::hdr.tcp.$valid
        # - L[25..27]b: egress::hdr.tcp.res if egress::hdr.tcp.$valid
        # - L[22..24]b: egress::hdr.tcp.ecn if egress::hdr.tcp.$valid
        # - L[16..21]b: egress::hdr.tcp.ctrl if egress::hdr.tcp.$valid
        # - L[0..15]b: egress::hdr.tcp.window if egress::hdr.tcp.$valid
    TW13: B22(5)
        # - L[16..31]b: egress::hdr.tcp.checksum if egress::hdr.tcp.$valid
        # - L[0..15]b: egress::hdr.tcp.urgent_ptr if egress::hdr.tcp.$valid
    TW5: B22(6)
        # - L[16..31]b: egress::hdr.udp.sport if egress::hdr.udp.$valid
        # - L[0..15]b: egress::hdr.udp.dport if egress::hdr.udp.$valid
    TW12: B22(6)
        # - L[16..31]b: egress::hdr.udp.len if egress::hdr.udp.$valid
        # - L[0..15]b: egress::hdr.udp.checksum if egress::hdr.udp.$valid
    TW5: B22(1)
        # - L[24..31]b: egress::hdr.icmp.icmp_type if egress::hdr.icmp.$valid
        # - L[16..23]b: egress::hdr.icmp.icmp_code if egress::hdr.icmp.$valid
        # - L[0..15]b: egress::hdr.icmp.checksum if egress::hdr.icmp.$valid
    TW12: B22(1)
        # - L[16..31]b: egress::hdr.icmp.identifier if egress::hdr.icmp.$valid
        # - L[0..15]b: egress::hdr.icmp.sequence_number if egress::hdr.icmp.$valid
    TW22: B22(1)  # egress::hdr.icmp.timestamp.32-63 if egress::hdr.icmp.$valid
    TW13: B22(1)  # egress::hdr.icmp.timestamp.0-31 if egress::hdr.icmp.$valid
  checksum 0:
    - TW4: { }
        # - L[28..31]b: egress::hdr.ipv4.version
        # - L[24..27]b: egress::hdr.ipv4.ihl
        # - L[18..23]b: egress::hdr.ipv4.dscp
        # - L[16..17]b: egress::hdr.ipv4.ecn
        # - L[0..15]b: egress::hdr.ipv4.total_len
    - TW7: { }
        # - L[16..31]b: egress::hdr.ipv4.identification
        # - L[13..15]b: egress::hdr.ipv4.flags
        # - L[0..12]b: egress::hdr.ipv4.frag_offset
    - B18: { swap: 1 }  # egress::hdr.ipv4.ttl
    - TB5: { }  # egress::hdr.ipv4.protocol
    - TW20: { }  # egress::hdr.ipv4.src_addr
    - TW21: { }  # egress::hdr.ipv4.dst_addr
  drop_ctl: B19(0..2)  # L[0..2]b: egress::eg_intr_md_for_dprsr.drop_ctl
  egress_unicast_port: H17(0..8)  # L[0..8]b: egress::eg_intr_md.egress_port
stage 0 ingress:
  hash_action tbl_act 0:
    p4: { name: tbl_act }
    row: 0
    bus: 0
    gateway:
      name: tbl_act-gateway
      row: 0
      bus: 0
      unit: 0
      0x0: tbl_act_0
      miss: tbl_act_0
      condition: 
        expression: "true(always hit)"
        true: tbl_act_0
        false: tbl_act_0
    next: tbl_act_0
    instruction: tbl_act($DEFAULT, $DEFAULT)
    actions:
      act_0(0, 1):
      - default_action: { allowed: true }
      - handle: 0x20000001
      - set hasExited, 0
    default_action: act_0
stage 1 ingress:
  hash_action tbl_act_0 0:
    p4: { name: tbl_act_0 }
    row: 0
    bus: 0
    gateway:
      name: cond-1
      input_xbar:
        exact group 0: { 7: hdr.packet_out.$valid }
      row: 0
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 7: hdr.packet_out.$valid }
      0x1: tbl_act_3
      miss: run_table
      condition: 
        expression: "(hdr.packet_out.$valid == 1)"
        true: tbl_act_3
        false: tbl_act_3
    next: tbl_act_3
    instruction: tbl_act_0(action, $DEFAULT)
    actions:
      act(1, 1):
      - default_action: { allowed: true }
      - handle: 0x20000002
      - set ig_intr_md_for_tm.ucast_egress_port, hdr.packet_out.egress_port
      - set fabric_metadata.is_controller_packet_out, 1
      - set hasExited, 1
    default_action: act
stage 2 ingress:
  hash_action tbl_act_3 0:
    p4: { name: tbl_act_3 }
    row: 1
    bus: 1
    gateway:
      name: cond-2
      input_xbar:
        exact group 0: { 6: hasExited }
      row: 1
      bus: 1
      unit: 1
      payload: 0x1
      format: { action: 0..0 }
      match: { 6: hasExited }
      0b*0: tbl_act_1
      miss: run_table
      condition: 
        expression: "(!hasExited)"
        true: tbl_act_1
        false: END
    next: END
    instruction: tbl_act_3(action, $DEFAULT)
    actions:
      act_3(1, 0):
      - default_action: { allowed: true }
      - handle: 0x20000020
    default_action: act_3
  hash_action tbl_act_1 1:
    p4: { name: tbl_act_1 }
    row: 1
    bus: 0
    gateway:
      name: cond-3
      input_xbar:
        exact group 0: { 2: hdr.vlan_tag.$valid }
      row: 1
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 2: hdr.vlan_tag.$valid }
      0b*****1: tbl_act_2
      miss: run_table
      condition: 
        expression: "(hdr.vlan_tag.$valid == 1)"
        true: tbl_act_2
        false: tbl_act_2
    next: tbl_act_2
    instruction: tbl_act_1(action, $DEFAULT)
    actions:
      act_1(1, 1):
      - default_action: { allowed: true }
      - handle: 0x20000003
      - set fabric_metadata.eth_type, hdr.vlan_tag.eth_type
      - set fabric_metadata.vlan_id.0-7, hdr.vlan_tag.vlan_id.0-7
      - set fabric_metadata.vlan_id.8-11, hdr.vlan_tag.vlan_id.8-11
      - set B8(4..7), B7(4..7)
    default_action: act_1
  hash_action tbl_act_2 2:
    p4: { name: tbl_act_2 }
    row: 0
    bus: 1
    gateway:
      name: cond-4
      input_xbar:
        exact group 0: { 14: hdr.mpls.$valid }
      row: 0
      bus: 1
      unit: 1
      payload: 0x1
      format: { action: 0..0 }
      match: { 6: hdr.mpls.$valid }
      0b*0: filtering_ingress_port_vlan
      miss: run_table
      condition: 
        expression: "(!(hdr.mpls.$valid == 1))"
        true: filtering_ingress_port_vlan
        false: filtering_ingress_port_vlan
    next: filtering_ingress_port_vlan
    instruction: tbl_act_2(action, $DEFAULT)
    actions:
      act_2(1, 2):
      - default_action: { allowed: true }
      - handle: 0x20000004
      - set fabric_metadata.mpls_ttl, 65
    default_action: act_2
stage 3 ingress:
  ternary_match filtering_ingress_port_vlan 0:
    p4: { name: FabricIngress.filtering.ingress_port_vlan }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: exact, size: 9, full_size: 9 }
      hdr.vlan_tag.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.vlan_tag.vlan_id: { type: ternary, size: 12, full_size: 12 }
    row: 2
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 2: hdr.vlan_tag.$valid, 8: ig_intr_md.ingress_port.0-7, 16: ig_intr_md.ingress_port.8-8, 24: hdr.vlan_tag.vlan_id.8-11, 32: hdr.vlan_tag.vlan_id.0-7 }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    next: filtering_fwd_classifier
    indirect: filtering_ingress_port_vlan$tind
  counter filtering_ingress_port_vlan$stats.FabricIngress.filtering.ingress_port_vlan_counter:
    p4: { name: FabricIngress.filtering.ingress_port_vlan_counter }
    row: 9
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_indirect filtering_ingress_port_vlan$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 2: hdr.vlan_tag.$valid, 8: ig_intr_md.ingress_port.0-7, 16: ig_intr_md.ingress_port.8-8, 24: hdr.vlan_tag.vlan_id.8-11, 32: hdr.vlan_tag.vlan_id.0-7 }
    format: { action: 0..1, immediate: 2..13 }
    action_bus: { 16 : immediate(0..7), 17 : immediate(8..11) }
    stats: filtering_ingress_port_vlan$stats.FabricIngress.filtering.ingress_port_vlan_counter($DIRECT, $DEFAULT)
    instruction: filtering_ingress_port_vlan$tind(action, $DEFAULT)
    actions:
      FabricIngress.filtering.deny(0, 1):
      - default_action: { allowed: true }
      - handle: 0x20000005
      - {  }
      - set fabric_metadata.skip_forwarding, 1
      - set fabric_metadata.skip_next, 1
      - filtering_ingress_port_vlan$stats.FabricIngress.filtering.ingress_port_vlan_counter($DIRECT)
      FabricIngress.filtering.permit(1, 0):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000006
      - {  }
      - filtering_ingress_port_vlan$stats.FabricIngress.filtering.ingress_port_vlan_counter($DIRECT)
      FabricIngress.filtering.permit_with_internal_vlan(2, 2):
      - p4_param_order: {vlan_id: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000007
      - { vlan_id.0-7: immediate(0..7), vlan_id.8-11: immediate(8..11) }
      - set fabric_metadata.vlan_id.0-7, vlan_id.0-7
      - set fabric_metadata.vlan_id.8-11, vlan_id.8-11
      - filtering_ingress_port_vlan$stats.FabricIngress.filtering.ingress_port_vlan_counter($DIRECT)
    default_action: FabricIngress.filtering.deny
  ternary_match filtering_fwd_classifier 1:
    p4: { name: FabricIngress.filtering.fwd_classifier }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: exact, size: 9, full_size: 9 }
      hdr.ethernet.dst_addr: { type: ternary, size: 48, full_size: 48 }
      fabric_metadata.eth_type: { type: exact, size: 16, full_size: 16 }
    row: [ 0, 1 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 1: { 0: hdr.ethernet.dst_addr.16-47(16..31), 16: hdr.ethernet.dst_addr.16-47(0..15), 32: fabric_metadata.eth_type(0..7) }
      ternary group 2: { 0: fabric_metadata.eth_type(8..15), 8: hdr.ethernet.dst_addr.0-15, 24: ig_intr_md.ingress_port.0-7, 32: ig_intr_md.ingress_port.8-8 }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0x155 }
    - { group: 2, dirtcam: 0x155 }
    next: cond-5
    indirect: filtering_fwd_classifier$tind
  counter filtering_fwd_classifier$stats.FabricIngress.filtering.fwd_classifier_counter:
    p4: { name: FabricIngress.filtering.fwd_classifier_counter }
    row: 13
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_indirect filtering_fwd_classifier$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 0: hdr.ethernet.dst_addr.16-47(16..31), 16: hdr.ethernet.dst_addr.16-47(0..15), 32: fabric_metadata.eth_type(0..7) }
      ternary group 2: { 0: fabric_metadata.eth_type(8..15), 8: hdr.ethernet.dst_addr.0-15, 24: ig_intr_md.ingress_port.0-7, 32: ig_intr_md.ingress_port.8-8 }
    format: { action: 0..0, immediate: 1..3 }
    action_bus: { 0 : immediate(0..2) }
    stats: filtering_fwd_classifier$stats.FabricIngress.filtering.fwd_classifier_counter($DIRECT, $DEFAULT)
    instruction: filtering_fwd_classifier$tind(action, $DEFAULT)
    actions:
      FabricIngress.filtering.set_forwarding_type(0, 3):
      - p4_param_order: {fwd_type: 3 }
      - default_action: { allowed: true }
      - handle: 0x20000008
      - { fwd_type: immediate(0..2) }
      - set fabric_metadata.fwd_type, fwd_type
      - filtering_fwd_classifier$stats.FabricIngress.filtering.fwd_classifier_counter($DIRECT)
    default_action: FabricIngress.filtering.set_forwarding_type
    default_action_parameters:
      fwd_type: 0
stage 4 ingress:
  gateway cond-5 0:
    name: cond-5
    input_xbar:
      exact group 0: { 10: fabric_metadata.skip_forwarding }
    row: 1
    bus: 1
    unit: 1
    match: { 2: fabric_metadata.skip_forwarding }
    0b*****0: forwarding_bridging
    miss: acl_acl
    condition: 
      expression: "(fabric_metadata.skip_forwarding == 0)"
      true: forwarding_bridging
      false: acl_acl
  ternary_match forwarding_bridging 1:
    p4: { name: FabricIngress.forwarding.bridging }
    p4_param_order: 
      fabric_metadata.vlan_id: { type: exact, size: 12, full_size: 12 }
      hdr.ethernet.dst_addr: { type: ternary, size: 48, full_size: 48 }
    row: [ 0, 1 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.dst_addr.16-47, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 1: { 0: fabric_metadata.vlan_id.0-7, 8: hdr.ethernet.dst_addr.0-15(8..15), 16: fabric_metadata.vlan_id.8-11 }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    - { group: 1, dirtcam: 0x15 }
    gateway:
      name: cond-6
      input_xbar:
        exact group 0: { 3: fabric_metadata.fwd_type }
      row: 1
      bus: 0
      unit: 0
      match: { 3: fabric_metadata.fwd_type }
      0b**000: run_table
      miss: forwarding_mpls
      condition: 
        expression: "(fabric_metadata.fwd_type == 0)"
        true: forwarding_bridging
        false: forwarding_mpls
    next: acl_acl
    indirect: forwarding_bridging$tind
  counter forwarding_bridging$stats.FabricIngress.forwarding.bridging_counter:
    p4: { name: FabricIngress.forwarding.bridging_counter }
    row: 5
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_indirect forwarding_bridging$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.dst_addr.16-47, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 1: { 0: fabric_metadata.vlan_id.0-7, 8: hdr.ethernet.dst_addr.0-15(8..15), 16: fabric_metadata.vlan_id.8-11 }
    format: { action: 0..0, immediate: 1..32 }
    action_bus: { 96..99 : immediate(0..31) }
    stats: forwarding_bridging$stats.FabricIngress.forwarding.bridging_counter($DIRECT, $DEFAULT)
    instruction: forwarding_bridging$tind(action, $DEFAULT)
    actions:
      FabricIngress.forwarding.set_next_id_bridging(1, 1):
      - p4_param_order: {next_id: 32 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000009
      - { next_id: immediate(0..31) }
      - set fabric_metadata.next_id, next_id
      - forwarding_bridging$stats.FabricIngress.forwarding.bridging_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000000a
      - {  }
    default_only_action: nop
  exact_match forwarding_mpls 2:
    p4: { name: FabricIngress.forwarding.mpls }
    p4_param_order: 
      fabric_metadata.mpls_label: { type: exact, size: 20, full_size: 20 }
    row: [ 7, 6 ]
    bus: [ 0, 0 ]
    column:
    - [ 2, 3 ]
    - [ 2, 3 ]
    ways:
      - [0, 0, 0x0, [7, 2]]
      - [0, 1, 0x0, [7, 3]]
      - [0, 2, 0x0, [6, 2]]
      - [0, 3, 0x0, [6, 3]]
    input_xbar:
      exact group 0: { 16: fabric_metadata.mpls_label.4-19, 36: fabric_metadata.mpls_label.0-3 }
      hash 0:
        0..5: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.4-19(0..5)
        10..15: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.4-19(0..5)
        20..25: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.4-19(0..5)
        30..35: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.4-19(0..5)
        6..9: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.0-3
        16..19: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.0-3
        26..29: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.0-3
        36..39: random(fabric_metadata.mpls_label.4-19(6..15)) ^ fabric_metadata.mpls_label.0-3
      hash group 0:
        table: [0]
        seed: 0x9d20ba697d
    format: { action(0): 0..0, immediate(0): 1..32, version(0): 112..115, match(0): 38..47 }
    match: [ fabric_metadata.mpls_label.4-19(6..7), fabric_metadata.mpls_label.4-19(8..15) ]
    gateway:
      name: cond-7
      input_xbar:
        exact group 0: { 3: fabric_metadata.fwd_type }
      row: 0
      bus: 1
      unit: 1
      match: { 3: fabric_metadata.fwd_type }
      0b**001: run_table
      miss: forwarding_routing_v4
      condition: 
        expression: "(fabric_metadata.fwd_type == 1)"
        true: forwarding_mpls
        false: forwarding_routing_v4
    next: acl_acl
    action_bus: { 100..103 : immediate(0..31) }
    stats: forwarding_mpls$stats.FabricIngress.forwarding.mpls_counter($DIRECT, $DEFAULT)
    instruction: forwarding_mpls(action, $DEFAULT)
    actions:
      FabricIngress.forwarding.pop_mpls_and_next(1, 2):
      - p4_param_order: {next_id: 32 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000000b
      - { next_id: immediate(0..31) }
      - set fabric_metadata.mpls_label.0-3, 0
      - set fabric_metadata.mpls_label.4-19, 0
      - set fabric_metadata.next_id, next_id
      - forwarding_mpls$stats.FabricIngress.forwarding.mpls_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000000c
      - {  }
    default_only_action: nop
  counter forwarding_mpls$stats.FabricIngress.forwarding.mpls_counter:
    p4: { name: FabricIngress.forwarding.mpls_counter }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_match forwarding_routing_v4 3:
    p4: { name: FabricIngress.forwarding.routing_v4 }
    p4_param_order: 
      hdr.ipv4.dst_addr: { type: lpm, size: 32, full_size: 32 }
    row: [ 2, 3 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 1: { 24: hdr.ipv4.dst_addr(8..23) }
      ternary group 2: { 0: hdr.ipv4.dst_addr(24..31), 8: hdr.ipv4.dst_addr(0..7) }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0x140 }
    - { group: 2, dirtcam: 0x5 }
    gateway:
      name: cond-8
      input_xbar:
        exact group 0: { 3: fabric_metadata.fwd_type }
      row: 0
      bus: 0
      unit: 0
      match: { 3: fabric_metadata.fwd_type }
      0b**010: run_table
      miss: acl_acl
      condition: 
        expression: "(fabric_metadata.fwd_type == 2)"
        true: forwarding_routing_v4
        false: acl_acl
    next: acl_acl
    indirect: forwarding_routing_v4$tind
  counter forwarding_routing_v4$stats.FabricIngress.forwarding.routing_v4_counter:
    p4: { name: FabricIngress.forwarding.routing_v4_counter }
    row: 9
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_indirect forwarding_routing_v4$tind:
    row: 1
    bus: 0
    column: 2
    input_xbar:
      ternary group 1: { 24: hdr.ipv4.dst_addr(8..23) }
      ternary group 2: { 0: hdr.ipv4.dst_addr(24..31), 8: hdr.ipv4.dst_addr(0..7) }
    format: { action: 0..1, immediate: 2..33 }
    action_bus: { 104..107 : immediate(0..31) }
    stats: forwarding_routing_v4$stats.FabricIngress.forwarding.routing_v4_counter($DIRECT, $DEFAULT)
    instruction: forwarding_routing_v4$tind(action, $DEFAULT)
    actions:
      FabricIngress.forwarding.set_next_id_routing_v4(1, 4):
      - p4_param_order: {next_id: 32 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000000d
      - { next_id: immediate(0..31) }
      - set fabric_metadata.next_id, next_id
      - forwarding_routing_v4$stats.FabricIngress.forwarding.routing_v4_counter($DIRECT)
      FabricIngress.forwarding.nop_routing_v4(2, 0):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000000e
      - {  }
      - forwarding_routing_v4$stats.FabricIngress.forwarding.routing_v4_counter($DIRECT)
      nop(-1, 3):
      - default_only_action: { allowed: true }
      - handle: 0x2000000f
      - {  }
    default_only_action: nop
stage 5 ingress:
  ternary_match acl_acl 0:
    p4: { name: FabricIngress.acl.acl, size: 128 }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: ternary, size: 9, full_size: 9 }
      fabric_metadata.ip_proto: { type: ternary, size: 8, full_size: 8 }
      fabric_metadata.l4_sport: { type: ternary, size: 16, full_size: 16 }
      fabric_metadata.l4_dport: { type: ternary, size: 16, full_size: 16 }
      hdr.ethernet.dst_addr: { type: ternary, size: 48, full_size: 48 }
      hdr.ethernet.src_addr: { type: ternary, size: 48, full_size: 48 }
      hdr.vlan_tag.vlan_id: { type: ternary, size: 12, full_size: 12 }
      fabric_metadata.eth_type: { type: ternary, size: 16, full_size: 16 }
      hdr.ipv4.src_addr: { type: ternary, size: 32, full_size: 32 }
      hdr.ipv4.dst_addr: { type: ternary, size: 32, full_size: 32 }
      hdr.icmp.icmp_type: { type: ternary, size: 8, full_size: 8 }
      hdr.icmp.icmp_code: { type: ternary, size: 8, full_size: 8 }
    row: [ 0, 1, 2, 3, 4, 5 ]
    bus: [ 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.src_addr.16-47(0..7), 8: hdr.ethernet.dst_addr.16-47(8..23), 24: hdr.ethernet.src_addr.16-47(24..31), 32: hdr.ipv4.src_addr(0..7) }
      ternary group 1: { 0: hdr.ethernet.src_addr.16-47(16..23), 8: hdr.ipv4.src_addr(24..31), 16: hdr.ipv4.dst_addr(0..7), 24: hdr.ethernet.src_addr.16-47(8..15), 32: hdr.ipv4.src_addr(16..23) }
      ternary group 2: { 0: hdr.ipv4.dst_addr(24..31), 8: fabric_metadata.l4_sport(0..7), 16: hdr.ipv4.src_addr(8..15), 24: hdr.ipv4.dst_addr(16..23), 32: fabric_metadata.l4_sport(8..15) }
      ternary group 3: { 0: hdr.ipv4.dst_addr(8..15), 8: fabric_metadata.l4_dport, 24: hdr.icmp.icmp_code, 32: hdr.icmp.icmp_type }
      ternary group 4: { 0: hdr.ethernet.src_addr.0-15, 16: fabric_metadata.eth_type, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 5: { 0: fabric_metadata.ip_proto, 8: hdr.ethernet.dst_addr.0-15(8..15), 16: ig_intr_md.ingress_port.0-7, 24: hdr.vlan_tag.vlan_id.8-11, 32: hdr.vlan_tag.vlan_id.0-7 }
      byte group 0: { 0: ig_intr_md.ingress_port.8-8 }
      byte group 1: { 0: hdr.ethernet.dst_addr.16-47(0..7) }
      byte group 2: { 0: hdr.ethernet.dst_addr.16-47(24..31) }
    match:
    - { group: 0, byte_group: 1, byte_config: 0, dirtcam: 0x555 }
    - { group: 1, byte_group: 1, byte_config: 1, dirtcam: 0x555 }
    - { group: 2, byte_group: 2, byte_config: 0, dirtcam: 0x555 }
    - { group: 3, byte_group: 2, byte_config: 1, dirtcam: 0x555 }
    - { group: 4, byte_group: 0, byte_config: 0, dirtcam: 0x555 }
    - { group: 5, byte_config: 3, dirtcam: 0x155 }
    next: next_xconnect
    indirect: acl_acl$tind
  counter acl_acl$stats.FabricIngress.acl.acl_counter:
    p4: { name: FabricIngress.acl.acl_counter }
    row: 9
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  ternary_indirect acl_acl$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ethernet.src_addr.16-47(0..7), 8: hdr.ethernet.dst_addr.16-47(8..23), 24: hdr.ethernet.src_addr.16-47(24..31), 32: hdr.ipv4.src_addr(0..7) }
      ternary group 1: { 0: hdr.ethernet.src_addr.16-47(16..23), 8: hdr.ipv4.src_addr(24..31), 16: hdr.ipv4.dst_addr(0..7), 24: hdr.ethernet.src_addr.16-47(8..15), 32: hdr.ipv4.src_addr(16..23) }
      ternary group 2: { 0: hdr.ipv4.dst_addr(24..31), 8: fabric_metadata.l4_sport(0..7), 16: hdr.ipv4.src_addr(8..15), 24: hdr.ipv4.dst_addr(16..23), 32: fabric_metadata.l4_sport(8..15) }
      ternary group 3: { 0: hdr.ipv4.dst_addr(8..15), 8: fabric_metadata.l4_dport, 24: hdr.icmp.icmp_code, 32: hdr.icmp.icmp_type }
      ternary group 4: { 0: hdr.ethernet.src_addr.0-15, 16: fabric_metadata.eth_type, 32: hdr.ethernet.dst_addr.0-15(0..7) }
      ternary group 5: { 0: fabric_metadata.ip_proto, 8: hdr.ethernet.dst_addr.0-15(8..15), 16: ig_intr_md.ingress_port.0-7, 24: hdr.vlan_tag.vlan_id.8-11, 32: hdr.vlan_tag.vlan_id.0-7 }
      byte group 0: { 0: ig_intr_md.ingress_port.8-8 }
      byte group 1: { 0: hdr.ethernet.dst_addr.16-47(0..7) }
      byte group 2: { 0: hdr.ethernet.dst_addr.16-47(24..31) }
    format: { action: 0..2, immediate: 3..34 }
    action_bus: { 32..33 : immediate(0..15), 96..99 : immediate(0..31) }
    stats: acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT, $DEFAULT)
    instruction: acl_acl$tind(action, $DEFAULT)
    actions:
      FabricIngress.acl.set_next_id_acl(0, 1):
      - p4_param_order: {next_id: 32 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000010
      - { next_id: immediate(0..31) }
      - set fabric_metadata.next_id, next_id
      - acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT)
      FabricIngress.acl.punt_to_cpu(1, 2):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000011
      - { $constant0: immediate(0..8), $constant0: 320 }
      - set ig_intr_md_for_tm.ucast_egress_port, $constant0
      - set fabric_metadata.skip_next, 1
      - acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT)
      FabricIngress.acl.clone_to_cpu(2, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000012
      - {  }
      - set fabric_metadata.clone_to_cpu, 1
      - acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT)
      FabricIngress.acl.drop(3, 4):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000013
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      - set fabric_metadata.skip_next, 1
      - acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT)
      FabricIngress.acl.nop_acl(4, 0):
      - default_action: { allowed: true }
      - handle: 0x20000014
      - {  }
      - acl_acl$stats.FabricIngress.acl.acl_counter($DIRECT)
    default_action: FabricIngress.acl.nop_acl
stage 6 ingress:
  exact_match next_xconnect 0:
    p4: { name: FabricIngress.next.xconnect }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: exact, size: 9, full_size: 9 }
      fabric_metadata.next_id: { type: exact, size: 32, full_size: 32 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    ways:
      - [0, 0, 0x0, [7, 2]]
      - [0, 1, 0x0, [7, 3]]
      - [0, 2, 0x0, [7, 4]]
      - [0, 3, 0x0, [7, 5]]
    input_xbar:
      exact group 0: { 0: fabric_metadata.next_id, 32: ig_intr_md.ingress_port.0-7, 40: ig_intr_md.ingress_port.8-8 }
      hash 0:
        0: random(fabric_metadata.next_id(1..31)) ^ fabric_metadata.next_id(0)
        10: random(fabric_metadata.next_id(1..31)) ^ fabric_metadata.next_id(0)
        20: random(fabric_metadata.next_id(1..31)) ^ fabric_metadata.next_id(0)
        30: random(fabric_metadata.next_id(1..31)) ^ fabric_metadata.next_id(0)
        1..8: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.0-7
        11..18: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.0-7
        21..28: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.0-7
        31..38: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.0-7
        9: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.8-8
        19: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.8-8
        29: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.8-8
        39: random(fabric_metadata.next_id(1..31)) ^ ig_intr_md.ingress_port.8-8
      hash group 0:
        table: [0]
        seed: 0xc8c1a2f2d8
    format: { action(0): 0..1, immediate(0): 2..33, version(0): 112..115, match(0): [65..71, 40..63 ] }
    match: [ fabric_metadata.next_id(1..7), fabric_metadata.next_id(8..15), fabric_metadata.next_id(16..23), fabric_metadata.next_id(24..31) ]
    gateway:
      name: cond-9
      input_xbar:
        exact group 0: { 48: fabric_metadata.skip_next }
      row: 7
      bus: 0
      unit: 0
      match: { 0: fabric_metadata.skip_next }
      0b*******0: run_table
      miss: END
      condition: 
        expression: "(fabric_metadata.skip_next == 0)"
        true: next_xconnect
        false: END
    next: next_next_vlan
    action_bus: { 32..33 : immediate(0..15), 96..99 : immediate(0..31) }
    stats: next_xconnect$stats.FabricIngress.next.xconnect_counter($DIRECT, $DEFAULT)
    instruction: next_xconnect(action, $DEFAULT)
    actions:
      FabricIngress.next.output_xconnect(1, 1):
      - p4_param_order: {port_num: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000015
      - { port_num: immediate(0..8) }
      - set ig_intr_md_for_tm.ucast_egress_port, port_num
      - next_xconnect$stats.FabricIngress.next.xconnect_counter($DIRECT)
      FabricIngress.next.set_next_id_xconnect(2, 2):
      - p4_param_order: {next_id: 32 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000016
      - { next_id: immediate(0..31) }
      - set fabric_metadata.next_id, next_id
      - next_xconnect$stats.FabricIngress.next.xconnect_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000017
      - {  }
    default_only_action: nop
  counter next_xconnect$stats.FabricIngress.next.xconnect_counter:
    p4: { name: FabricIngress.next.xconnect_counter }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
stage 7 ingress:
  exact_match next_next_vlan 0:
    p4: { name: FabricIngress.next.next_vlan }
    p4_param_order: 
      fabric_metadata.next_id: { type: exact, size: 32, full_size: 32 }
    row: 6
    bus: 0
    column: [ 2, 3, 4, 5 ]
    ways:
      - [0, 0, 0x0, [6, 2]]
      - [0, 1, 0x0, [6, 3]]
      - [0, 2, 0x0, [6, 4]]
      - [0, 3, 0x0, [6, 5]]
    input_xbar:
      exact group 0: { 0: fabric_metadata.next_id }
      hash 0:
        0..7: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        10..17: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        20..27: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        30..37: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        8..9: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        18..19: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        28..29: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        38..39: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
      hash group 0:
        table: [0]
        seed: 0x8fabaaab2d
    format: { immediate(0): 0..11, version(0): 112..115, match(0): [50..55, 32..47 ] }
    match: [ fabric_metadata.next_id(10..15), fabric_metadata.next_id(16..23), fabric_metadata.next_id(24..31) ]
    next: next_multicast
    action_bus: { 16 : immediate(0..7), 17 : immediate(8..11) }
    stats: next_next_vlan$stats.FabricIngress.next.next_vlan_counter($DIRECT, $DEFAULT)
    instruction: next_next_vlan($DEFAULT, $DEFAULT)
    actions:
      FabricIngress.next.set_vlan(0, 1):
      - p4_param_order: {vlan_id: 12 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000001e
      - { vlan_id.0-7: immediate(0..7), vlan_id.8-11: immediate(8..11) }
      - set fabric_metadata.vlan_id.0-7, vlan_id.0-7
      - set fabric_metadata.vlan_id.8-11, vlan_id.8-11
      - next_next_vlan$stats.FabricIngress.next.next_vlan_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000001f
      - {  }
    default_only_action: nop
  counter next_next_vlan$stats.FabricIngress.next.next_vlan_counter:
    p4: { name: FabricIngress.next.next_vlan_counter }
    row: 9
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  exact_match next_multicast 1:
    p4: { name: FabricIngress.next.multicast }
    p4_param_order: 
      fabric_metadata.next_id: { type: exact, size: 32, full_size: 32 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    ways:
      - [1, 0, 0x0, [7, 2]]
      - [1, 1, 0x0, [7, 3]]
      - [1, 2, 0x0, [7, 4]]
      - [1, 3, 0x0, [7, 5]]
    input_xbar:
      exact group 0: { 64: fabric_metadata.next_id }
      hash 1:
        0..7: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        10..17: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        20..27: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        30..37: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        8..9: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        18..19: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        28..29: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        38..39: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
      hash group 1:
        table: [1]
        seed: 0xc0ecd85a37
    format: { immediate(0): 0..15, version(0): 112..115, match(0): [50..55, 32..47 ] }
    match: [ fabric_metadata.next_id(10..15), fabric_metadata.next_id(16..23), fabric_metadata.next_id(24..31) ]
    next: next_hashed
    action_bus: { 32..33 : immediate(0..15) }
    stats: next_multicast$stats.FabricIngress.next.multicast_counter($DIRECT, $DEFAULT)
    instruction: next_multicast($DEFAULT, $DEFAULT)
    actions:
      FabricIngress.next.set_mcast_group_id(0, 2):
      - p4_param_order: {group_id: 16 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000001c
      - { group_id: immediate(0..15) }
      - set ig_intr_md_for_tm.mcast_grp_a, group_id
      - set fabric_metadata.is_multicast, 1
      - next_multicast$stats.FabricIngress.next.multicast_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000001d
      - {  }
    default_only_action: nop
  counter next_multicast$stats.FabricIngress.next.multicast_counter:
    p4: { name: FabricIngress.next.multicast_counter }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  exact_match next_hashed 2:
    p4: { name: FabricIngress.next.hashed, action_profile: FabricIngress.next.hashed_selector }
    p4_param_order: 
      fabric_metadata.next_id: { type: exact, size: 32, full_size: 32 }
    row: 5
    bus: 0
    column: [ 2, 3, 4, 5 ]
    ways:
      - [2, 0, 0x0, [5, 2]]
      - [2, 1, 0x0, [5, 3]]
      - [2, 2, 0x0, [5, 4]]
      - [2, 3, 0x0, [5, 5]]
    input_xbar:
      exact group 1: { 0: fabric_metadata.next_id }
      hash 2:
        0..7: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        10..17: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        20..27: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        30..37: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(0..7)
        8..9: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        18..19: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        28..29: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
        38..39: random(fabric_metadata.next_id(10..31)) ^ fabric_metadata.next_id(8..9)
      hash group 2:
        table: [2]
        seed: 0x2487c4eb12
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 2..11, meter_pfe(0): 12..12, action_addr(0): 13..24, match(0): [50..55, 32..47 ] }
    match: [ fabric_metadata.next_id(10..15), fabric_metadata.next_id(16..23), fabric_metadata.next_id(24..31) ]
    next: END
    selector: next_hashed$selector.FabricIngress.next.hashed_selector(meter_addr, meter_pfe, $DEFAULT)
    selector_length: next_hashed$selector.FabricIngress.next.hashed_selector($DEFAULT, $DEFAULT)
    action: next_hashed$action_data.FabricIngress.next.hashed_selector(action_addr, $DEFAULT)
    stats: next_hashed$stats.FabricIngress.next.hashed_counter($DIRECT, $DEFAULT)
    instruction: next_hashed(action, $DEFAULT)
    actions:
      FabricIngress.next.output_hashed(0, 3):
      - p4_param_order: {port_num: 9 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000018
      - { port_num: $adf_h3(0..8) }
      - set ig_intr_md_for_tm.ucast_egress_port, port_num
      - next_hashed$stats.FabricIngress.next.hashed_counter($DIRECT)
      FabricIngress.next.routing_hashed(1, 4):
      - p4_param_order: {port_num: 9, smac: 48, dmac: 48 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000019
      - { port_num: $adf_h1(0..8), smac.0-15: $adf_h2, dmac.0-15: $adf_h3, dmac.16-47: $adf_f0, smac.16-47: $adf_f1 }
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set ig_intr_md_for_tm.ucast_egress_port, port_num
      - next_hashed$stats.FabricIngress.next.hashed_counter($DIRECT)
      FabricIngress.next.mpls_routing_hashed(2, 6):
      - p4_param_order: {port_num: 9, smac: 48, dmac: 48, label: 20 }
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x2000001a
      - { label.0-3: $adf_b0(0..3), port_num: $adf_h0(0..8), smac.0-15: $adf_h1, label.4-19: $adf_h2, dmac.0-15: $adf_h3, dmac.16-47: $adf_f0, smac.16-47: $adf_f1 }
      - set fabric_metadata.mpls_label.0-3, label.0-3
      - set fabric_metadata.mpls_label.4-19, label.4-19
      - set hdr.ethernet.src_addr.0-15, smac.0-15
      - set hdr.ethernet.src_addr.16-47, smac.16-47
      - set hdr.ethernet.dst_addr.0-15, dmac.0-15
      - set hdr.ethernet.dst_addr.16-47, dmac.16-47
      - set ig_intr_md_for_tm.ucast_egress_port, port_num
      - next_hashed$stats.FabricIngress.next.hashed_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x2000001b
      - {  }
    default_only_action: nop
  selection next_hashed$selector.FabricIngress.next.hashed_selector:
    p4: { name: FabricIngress.next.hashed_selector, size: 4 }
    row: 15
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    input_xbar:
      exact group 2: { 0: hdr.ipv4.src_addr, 32: hdr.ipv4.dst_addr, 64: fabric_metadata.l4_sport, 80: fabric_metadata.l4_dport, 96: fabric_metadata.ip_proto }
      hash 4:
        0..13: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 40: hdr.ipv4.src_addr, 72: hdr.ipv4.dst_addr })), 0..13)
      hash 5:
        0..13: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 0: fabric_metadata.l4_dport, 16: fabric_metadata.l4_sport, 32: fabric_metadata.ip_proto })), 0..13)
      hash group 3:
        table: [4, 5]
        seed: 0x0
    mode: fair 0
    non_linear: true
    pool_sizes: [120]
  action next_hashed$action_data.FabricIngress.next.hashed_selector:
    p4: { name: FabricIngress.next.hashed_selector, size: 64 }
    row: [ 15, 13 ]
    word: [ 0, 1 ]
    column:
    - 2
    - 3
    vpns: 
    - [ 0 ]
    - [ 0 ]
    home_row: [ 15, 13 ]
    format FabricIngress.next.output_hashed: { $adf_h3: 80..95 }
    format FabricIngress.next.routing_hashed: { $adf_h1: 48..63, $adf_h2: 64..79, $adf_h3: 80..95, $adf_f0: 192..223, $adf_f1: 224..255 }
    format FabricIngress.next.mpls_routing_hashed: { $adf_b0: 0..7, $adf_h0: 32..47, $adf_h1: 48..63, $adf_h2: 64..79, $adf_h3: 80..95, $adf_f0: 192..223, $adf_f1: 224..255 }
    action_bus: { 0 : $adf_b0, 64..65 : $adf_h2, 66..67 : $adf_h3, 36..37 : $adf_h0, 38..39 : $adf_h1, 96..99 : $adf_f0, 100..103 : $adf_f1 }
  counter next_hashed$stats.FabricIngress.next.hashed_counter:
    p4: { name: FabricIngress.next.hashed_counter }
    row: 5
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
stage 0 egress:
  hash_action tbl_act_4 1:
    p4: { name: tbl_act_4 }
    row: 0
    bus: 1
    gateway:
      name: tbl_act_4-gateway
      row: 0
      bus: 0
      unit: 1
      0x0: tbl_act_5
      miss: tbl_act_5
      condition: 
        expression: "true(always hit)"
        true: tbl_act_5
        false: tbl_act_5
    next: tbl_act_5
    instruction: tbl_act_4($DEFAULT, $DEFAULT)
    actions:
      act_5(0, 1):
      - default_action: { allowed: true }
      - handle: 0x20000021
      - set hasExited_0, 0
    default_action: act_5
stage 1 egress:
  hash_action tbl_act_5 1:
    p4: { name: tbl_act_5 }
    row: 0
    bus: 1
    gateway:
      name: cond-10
      input_xbar:
        exact group 0: { 16: fabric_metadata.is_controller_packet_out }
      row: 0
      bus: 1
      unit: 1
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: fabric_metadata.is_controller_packet_out }
      0b*******1: cond-11
      miss: run_table
      condition: 
        expression: "(fabric_metadata.is_controller_packet_out == 1)"
        true: cond-11
        false: cond-11
    next: cond-11
    instruction: tbl_act_5(action, $DEFAULT)
    actions:
      act_4(1, 1):
      - default_action: { allowed: true }
      - handle: 0x20000022
      - set hasExited_0, 1
    default_action: act_4
stage 2 egress:
  gateway cond-11 3:
    name: cond-11
    input_xbar:
      exact group 0: { 16: hasExited_0 }
    row: 2
    bus: 1
    unit: 1
    match: { 0: hasExited_0 }
    0b*******0: tbl_act_7
    miss: cond-14
    condition: 
      expression: "(!hasExited_0)"
      true: tbl_act_7
      false: cond-14
  hash_action tbl_act_7 4:
    p4: { name: tbl_act_7 }
    row: 0
    bus: 0
    gateway:
      name: cond-12
      input_xbar:
        exact group 0: { 24: eg_intr_md.egress_port(8), 32: eg_intr_md.egress_port(0..7) }
      row: 0
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: eg_intr_md.egress_port(0..7), 8: eg_intr_md.egress_port(8) }
      0b*******101000000: tbl_act_6
      miss: run_table
      condition: 
        expression: "(eg_intr_md.egress_port == 320)"
        true: tbl_act_6
        false: cond-14
    next: cond-14
    instruction: tbl_act_7(action, $DEFAULT)
    actions:
      act_7(1, 1):
      - default_action: { allowed: true }
      - handle: 0x20000024
      - set hdr.packet_in.$valid, 1
      - set hdr.packet_in.ingress_port, ig_intr_md.ingress_port
      - set hasExited_0, 1
    default_action: act_7
  hash_action tbl_act_6 5:
    p4: { name: tbl_act_6 }
    row: 2
    bus: 0
    gateway:
      name: cond-13
      input_xbar:
        exact group 0: { 49: fabric_metadata.is_multicast, 50: fabric_metadata.clone_to_cpu }
      row: 2
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 1: fabric_metadata.is_multicast, 10: fabric_metadata.clone_to_cpu }
      0b*****0********1: cond-14
      miss: run_table
      condition: 
        expression: "(fabric_metadata.is_multicast == 1 && fabric_metadata.clone_to_cpu == 0)"
        true: cond-14
        false: cond-14
    next: cond-14
    instruction: tbl_act_6(action, $DEFAULT)
    actions:
      act_6(1, 2):
      - default_action: { allowed: true }
      - handle: 0x20000023
      - set eg_intr_md_for_dprsr.drop_ctl, 1
    default_action: act_6
stage 3 egress:
  gateway cond-14 2:
    name: cond-14
    input_xbar:
      exact group 0: { 0: hasExited_0 }
    row: 1
    bus: 1
    unit: 1
    match: { 0: hasExited_0 }
    0b*******0: tbl_egress_next_set_mpls
    miss: END
    condition: 
      expression: "(!hasExited_0)"
      true: tbl_egress_next_set_mpls
      false: END
  hash_action tbl_egress_next_set_mpls 3:
    p4: { name: tbl_egress_next_set_mpls }
    row: 1
    bus: 1
    gateway:
      name: cond-16
      input_xbar:
        exact group 0: { 4: fabric_metadata.mpls_label.0-3, 8: fabric_metadata.mpls_label.4-19(8..15), 16: fabric_metadata.mpls_label.4-19(0..7) }
      row: 0
      bus: 1
      unit: 1
      payload: 0x1
      format: { action: 0..0 }
      match: { 4: fabric_metadata.mpls_label.0-3, 8: fabric_metadata.mpls_label.4-19(0..7), 16: fabric_metadata.mpls_label.4-19(8..15) }
      0x00000: run_table
      miss: tbl_act_8
      condition: 
        expression: "(fabric_metadata.mpls_label == 0)"
        true: tbl_egress_next_pop_mpls_if_present
        false: tbl_act_8
    next: tbl_egress_next_pop_mpls_if_present
    instruction: tbl_egress_next_set_mpls(action, $DEFAULT)
    actions:
      FabricEgress.egress_next.set_mpls(1, 1):
      - default_action: { allowed: true }
      - handle: 0x20000027
      - set hdr.mpls.$valid, 1
      - set hdr.mpls.label.4-19, fabric_metadata.mpls_label.4-19
      - set hdr.mpls.ttl, fabric_metadata.mpls_ttl
      - set fabric_metadata.eth_type, 34887
      - deposit-field B21(0..3), 1, B20
    default_action: FabricEgress.egress_next.set_mpls
  hash_action tbl_egress_next_pop_mpls_if_present 4:
    p4: { name: tbl_egress_next_pop_mpls_if_present }
    row: 0
    bus: 1
    gateway:
      name: cond-17
      input_xbar:
        exact group 0: { 28: hdr.mpls.$valid }
      row: 0
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 4: hdr.mpls.$valid }
      0b***1: tbl_act_8
      miss: run_table
      condition: 
        expression: "(hdr.mpls.$valid == 1)"
        true: tbl_act_8
        false: tbl_act_8
    next: tbl_act_8
    instruction: tbl_egress_next_pop_mpls_if_present(action, $DEFAULT)
    actions:
      FabricEgress.egress_next.pop_mpls_if_present(1, 2):
      - default_action: { allowed: true }
      - handle: 0x20000026
      - set hdr.mpls.$valid, 0
      - set fabric_metadata.eth_type, fabric_metadata.ip_eth_type
    default_action: FabricEgress.egress_next.pop_mpls_if_present
  hash_action tbl_act_8 5:
    p4: { name: tbl_act_8 }
    row: 2
    bus: 0
    gateway:
      name: cond-15
      input_xbar:
        exact group 0: { 32: eg_intr_md.egress_port, 48: ig_intr_md.ingress_port, 65: fabric_metadata.is_multicast }
      row: 1
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 17: fabric_metadata.is_multicast, 0: ig_intr_md.ingress_port(0..7), 8: ig_intr_md.ingress_port(8) }
      xor: { 0: eg_intr_md.egress_port(0..7), 8: eg_intr_md.egress_port(8) }
      0b******1********000000000: tbl_act_9
      miss: run_table
      condition: 
        expression: "(fabric_metadata.is_multicast == 1 && ig_intr_md.ingress_port == eg_intr_md.egress_port)"
        true: tbl_act_9
        false: tbl_act_9
    next: tbl_act_9
    instruction: tbl_act_8(action, $DEFAULT)
    actions:
      act_8(1, 3):
      - default_action: { allowed: true }
      - handle: 0x20000025
      - set eg_intr_md_for_dprsr.drop_ctl, 1
    default_action: act_8
stage 4 egress:
  hash_action tbl_act_9 4:
    p4: { name: tbl_act_9 }
    row: 0
    bus: 1
    gateway:
      name: cond-19
      input_xbar:
        exact group 0: { 44: hdr.mpls.$valid }
      row: 6
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 4: hdr.mpls.$valid }
      0b***1: tbl_act_10
      miss: run_table
      condition: 
        expression: "(hdr.mpls.$valid == 1)"
        true: tbl_act_10
        false: tbl_act_11
    next: tbl_act_11
    instruction: tbl_act_9(action, $DEFAULT)
    actions:
      act_10(1, 1):
      - default_action: { allowed: true }
      - handle: 0x2000002b
      - add hdr.mpls.ttl, hdr.mpls.ttl, 255
    default_action: act_10
  hash_action tbl_act_11 5:
    p4: { name: tbl_act_11 }
    row: 1
    bus: 1
    gateway:
      name: cond-21
      input_xbar:
        exact group 0: { 43: hdr.ipv4.$valid }
      row: 7
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 3: hdr.ipv4.$valid }
      0b****1: tbl_act_12
      miss: run_table
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true: tbl_act_12
        false: egress_next_egress_vlan
    next: egress_next_egress_vlan
    instruction: tbl_act_11(action, $DEFAULT)
    actions:
      act_12(1, 2):
      - default_action: { allowed: true }
      - handle: 0x2000002d
      - add hdr.ipv4.ttl, hdr.ipv4.ttl, 255
    default_action: act_12
stage 5 egress:
  hash_action tbl_act_10 2:
    p4: { name: tbl_act_10 }
    row: 0
    bus: 1
    gateway:
      name: cond-20
      input_xbar:
        exact group 0: { 8: hdr.mpls.ttl }
      row: 7
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: hdr.mpls.ttl }
      0x00: egress_next_egress_vlan
      miss: run_table
      condition: 
        expression: "(hdr.mpls.ttl == 0)"
        true: egress_next_egress_vlan
        false: egress_next_egress_vlan
    next: egress_next_egress_vlan
    instruction: tbl_act_10(action, $DEFAULT)
    actions:
      act_9(1, 2):
      - default_action: { allowed: true }
      - handle: 0x2000002c
      - set eg_intr_md_for_dprsr.drop_ctl, 1
    default_action: act_9
  hash_action tbl_act_12 1:
    p4: { name: tbl_act_12 }
    row: 1
    bus: 0
    gateway:
      name: cond-22
      input_xbar:
        exact group 0: { 0: hdr.ipv4.ttl }
      row: 0
      bus: 0
      unit: 0
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: hdr.ipv4.ttl }
      0x00: egress_next_egress_vlan
      miss: run_table
      condition: 
        expression: "(hdr.ipv4.ttl == 0)"
        true: egress_next_egress_vlan
        false: egress_next_egress_vlan
    next: egress_next_egress_vlan
    instruction: tbl_act_12(action, $DEFAULT)
    actions:
      act_11(1, 1):
      - default_action: { allowed: true }
      - handle: 0x2000002e
      - set eg_intr_md_for_dprsr.drop_ctl, 1
    default_action: act_11
  exact_match egress_next_egress_vlan 3:
    p4: { name: FabricEgress.egress_next.egress_vlan }
    p4_param_order: 
      fabric_metadata.vlan_id: { type: exact, size: 12, full_size: 12 }
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 6 ]
    ways:
      - [0, 0, 0x0, [7, 2]]
      - [0, 1, 0x0, [7, 3]]
      - [0, 2, 0x0, [7, 4]]
      - [0, 3, 0x0, [7, 6]]
    input_xbar:
      exact group 0: { 16: eg_intr_md.egress_port, 32: fabric_metadata.vlan_id }
      hash 0:
        0..4: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(0..4)
        10..14: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(0..4)
        20..24: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(0..4)
        30..34: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(0..4)
        5: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(8)
        15: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(8)
        25: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(8)
        35: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ eg_intr_md.egress_port(8)
        6..9: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ fabric_metadata.vlan_id(8..11)
        16..19: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ fabric_metadata.vlan_id(8..11)
        26..29: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ fabric_metadata.vlan_id(8..11)
        36..39: random(eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7)) ^ fabric_metadata.vlan_id(8..11)
      hash group 0:
        table: [0]
        seed: 0x5cf47acd63
    format: { version(0): 112..115, match(0): [45..47, 32..39 ] }
    match: [ eg_intr_md.egress_port(5..7), fabric_metadata.vlan_id(0..7) ]
    hit: END
    miss: tbl_egress_next_push_vlan
    stats: egress_next_egress_vlan$stats.FabricEgress.egress_next.egress_vlan_counter($DIRECT, $DEFAULT)
    instruction: egress_next_egress_vlan($DEFAULT, $DEFAULT)
    actions:
      FabricEgress.egress_next.pop_vlan(0, 3):
      - default_action: { allowed: false, reason: has_const_default }
      - handle: 0x20000028
      - set hdr.ethernet.eth_type, fabric_metadata.eth_type
      - set hdr.vlan_tag.$valid, 0
      - egress_next_egress_vlan$stats.FabricEgress.egress_next.egress_vlan_counter($DIRECT)
      nop(-1, 0):
      - default_only_action: { allowed: true }
      - handle: 0x20000029
    default_only_action: nop
  counter egress_next_egress_vlan$stats.FabricEgress.egress_next.egress_vlan_counter:
    p4: { name: FabricEgress.egress_next.egress_vlan_counter }
    row: 13
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    count: packets_and_bytes
    format: {packets(0): 64..91, bytes(0): 92..127, packets(1): 0..27, bytes(1): 28..63}
  hash_action tbl_egress_next_push_vlan 4:
    p4: { name: tbl_egress_next_push_vlan }
    row: 1
    bus: 1
    gateway:
      name: cond-18
      input_xbar:
        exact group 0: { 32: fabric_metadata.vlan_id }
      row: 0
      bus: 1
      unit: 1
      payload: 0x1
      format: { action: 0..0 }
      match: { 0: fabric_metadata.vlan_id(0..7), 8: fabric_metadata.vlan_id(8..11) }
      0x*ffe: run_table
      miss: END
      condition: 
        expression: "(fabric_metadata.vlan_id != 4094)"
        true: END
        false: END
    next: END
    instruction: tbl_egress_next_push_vlan(action, $DEFAULT)
    actions:
      FabricEgress.egress_next.push_vlan(1, 4):
      - default_action: { allowed: true }
      - handle: 0x2000002a
      - set hdr.vlan_tag.$valid, 1
      - set hdr.vlan_tag.eth_type, fabric_metadata.eth_type
      - set hdr.ethernet.eth_type, 33024
      - deposit-field H21(12..15), H19(4..7), H20
    default_action: FabricEgress.egress_next.push_vlan
primitives: "/onos/pipelines/fabric/src/main/resources/p4c-out/fabric/tofino/mavericks/pipe/fabric-tofino.prim.json"
